/* tslint:disable */
/* eslint-disable */
/**
 * clusters_mgmt
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * Contact: ocm-feedback@redhat.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { AWS } from '../model';
// @ts-ignore
import { AWSInfrastructureAccessRole } from '../model';
// @ts-ignore
import { AWSInfrastructureAccessRoleGrant } from '../model';
// @ts-ignore
import { AddOn } from '../model';
// @ts-ignore
import { AddOnInstallation } from '../model';
// @ts-ignore
import { AddOnVersion } from '../model';
// @ts-ignore
import { AlertsInfo } from '../model';
// @ts-ignore
import { CPUTotalsNodeRoleOSMetricNode } from '../model';
// @ts-ignore
import { CloudProvider } from '../model';
// @ts-ignore
import { CloudProviderData } from '../model';
// @ts-ignore
import { CloudRegion } from '../model';
// @ts-ignore
import { Cluster } from '../model';
// @ts-ignore
import { ClusterCredentials } from '../model';
// @ts-ignore
import { ClusterOperatorsInfo } from '../model';
// @ts-ignore
import { ClusterResources } from '../model';
// @ts-ignore
import { ClusterStatus } from '../model';
// @ts-ignore
import { Environment } from '../model';
// @ts-ignore
import { Event } from '../model';
// @ts-ignore
import { ExternalConfiguration } from '../model';
// @ts-ignore
import { Flavour } from '../model';
// @ts-ignore
import { Group } from '../model';
// @ts-ignore
import { HTPasswdUser } from '../model';
// @ts-ignore
import { IdentityProvider } from '../model';
// @ts-ignore
import { Ingress } from '../model';
// @ts-ignore
import { InlineObject } from '../model';
// @ts-ignore
import { InlineResponse200 } from '../model';
// @ts-ignore
import { InlineResponse2001 } from '../model';
// @ts-ignore
import { InlineResponse20010 } from '../model';
// @ts-ignore
import { InlineResponse20011 } from '../model';
// @ts-ignore
import { InlineResponse20012 } from '../model';
// @ts-ignore
import { InlineResponse20013 } from '../model';
// @ts-ignore
import { InlineResponse20014 } from '../model';
// @ts-ignore
import { InlineResponse20015 } from '../model';
// @ts-ignore
import { InlineResponse20016 } from '../model';
// @ts-ignore
import { InlineResponse20017 } from '../model';
// @ts-ignore
import { InlineResponse20018 } from '../model';
// @ts-ignore
import { InlineResponse20019 } from '../model';
// @ts-ignore
import { InlineResponse2002 } from '../model';
// @ts-ignore
import { InlineResponse20020 } from '../model';
// @ts-ignore
import { InlineResponse20021 } from '../model';
// @ts-ignore
import { InlineResponse20022 } from '../model';
// @ts-ignore
import { InlineResponse20023 } from '../model';
// @ts-ignore
import { InlineResponse20024 } from '../model';
// @ts-ignore
import { InlineResponse20025 } from '../model';
// @ts-ignore
import { InlineResponse20026 } from '../model';
// @ts-ignore
import { InlineResponse20027 } from '../model';
// @ts-ignore
import { InlineResponse20028 } from '../model';
// @ts-ignore
import { InlineResponse20029 } from '../model';
// @ts-ignore
import { InlineResponse2003 } from '../model';
// @ts-ignore
import { InlineResponse20030 } from '../model';
// @ts-ignore
import { InlineResponse20031 } from '../model';
// @ts-ignore
import { InlineResponse20032 } from '../model';
// @ts-ignore
import { InlineResponse20033 } from '../model';
// @ts-ignore
import { InlineResponse20034 } from '../model';
// @ts-ignore
import { InlineResponse20035 } from '../model';
// @ts-ignore
import { InlineResponse20036 } from '../model';
// @ts-ignore
import { InlineResponse2004 } from '../model';
// @ts-ignore
import { InlineResponse2005 } from '../model';
// @ts-ignore
import { InlineResponse2006 } from '../model';
// @ts-ignore
import { InlineResponse2007 } from '../model';
// @ts-ignore
import { InlineResponse2008 } from '../model';
// @ts-ignore
import { InlineResponse2009 } from '../model';
// @ts-ignore
import { Label } from '../model';
// @ts-ignore
import { LimitedSupportReason } from '../model';
// @ts-ignore
import { LimitedSupportReasonTemplate } from '../model';
// @ts-ignore
import { Log } from '../model';
// @ts-ignore
import { MachinePool } from '../model';
// @ts-ignore
import { Metadata } from '../model';
// @ts-ignore
import { NodesInfo } from '../model';
// @ts-ignore
import { OperatorIAMRole } from '../model';
// @ts-ignore
import { Product } from '../model';
// @ts-ignore
import { ProvisionShard } from '../model';
// @ts-ignore
import { SocketTotalsNodeRoleOSMetricNode } from '../model';
// @ts-ignore
import { Syncset } from '../model';
// @ts-ignore
import { UpgradePolicy } from '../model';
// @ts-ignore
import { UpgradePolicyState } from '../model';
// @ts-ignore
import { User } from '../model';
// @ts-ignore
import { Version } from '../model';
// @ts-ignore
import { VersionGate } from '../model';
// @ts-ignore
import { VersionGateAgreement } from '../model';
/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes the add-on.
         * @param {string} [addonId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AddonsAddonIdDelete: async (addonId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/addons/{addon_id}`
                .replace(`{${"addon_id"}}`, encodeURIComponent(String(addonId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the add-on.
         * @param {string} [addonId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AddonsAddonIdGet: async (addonId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/addons/{addon_id}`
                .replace(`{${"addon_id"}}`, encodeURIComponent(String(addonId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the add-on.
         * @param {string} [addonId] 
         * @param {AddOn} [addOn] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AddonsAddonIdPatch: async (addonId?: string, addOn?: AddOn, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/addons/{addon_id}`
                .replace(`{${"addon_id"}}`, encodeURIComponent(String(addonId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addOn, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of add-on versions.
         * @param {string} [addonId] 
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the add-on instead of the names of the columns of a table. For example, in order to sort the add-on versions descending by id the value should be:  &#x60;&#x60;&#x60;sql id desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the add-on version instead of the names of the columns of a table. For example, in order to retrieve all the add-on versions with an id starting with &#x60;0.1&#x60; the value should be:  &#x60;&#x60;&#x60;sql id like \&#39;0.1.%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the add-on versions that the user has permission to see will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AddonsAddonIdVersionsGet: async (addonId?: string, order?: string, page?: number, search?: string, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/addons/{addon_id}/versions`
                .replace(`{${"addon_id"}}`, encodeURIComponent(String(addonId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new add-on version and add it to the collection of add-ons.
         * @param {string} [addonId] 
         * @param {AddOnVersion} [addOnVersion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AddonsAddonIdVersionsPost: async (addonId?: string, addOnVersion?: AddOnVersion, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/addons/{addon_id}/versions`
                .replace(`{${"addon_id"}}`, encodeURIComponent(String(addonId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addOnVersion, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the add-on version.
         * @param {string} [addonId] 
         * @param {string} [versionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AddonsAddonIdVersionsVersionIdDelete: async (addonId?: string, versionId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/addons/{addon_id}/versions/{version_id}`
                .replace(`{${"addon_id"}}`, encodeURIComponent(String(addonId)))
                .replace(`{${"version_id"}}`, encodeURIComponent(String(versionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the add-on version.
         * @param {string} [addonId] 
         * @param {string} [versionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AddonsAddonIdVersionsVersionIdGet: async (addonId?: string, versionId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/addons/{addon_id}/versions/{version_id}`
                .replace(`{${"addon_id"}}`, encodeURIComponent(String(addonId)))
                .replace(`{${"version_id"}}`, encodeURIComponent(String(versionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the add-on version.
         * @param {string} [addonId] 
         * @param {string} [versionId] 
         * @param {AddOnVersion} [addOnVersion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AddonsAddonIdVersionsVersionIdPatch: async (addonId?: string, versionId?: string, addOnVersion?: AddOnVersion, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/addons/{addon_id}/versions/{version_id}`
                .replace(`{${"addon_id"}}`, encodeURIComponent(String(addonId)))
                .replace(`{${"version_id"}}`, encodeURIComponent(String(versionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addOnVersion, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of add-ons.
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the add-on instead of the names of the columns of a table. For example, in order to sort the add-ons descending by name the value should be:  &#x60;&#x60;&#x60;sql name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the add-on instead of the names of the columns of a table. For example, in order to retrieve all the add-ons with a name starting with &#x60;my&#x60; the value should be:  &#x60;&#x60;&#x60;sql name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the add-ons that the user has permission to see will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AddonsGet: async (order?: string, page?: number, search?: string, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/addons`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new add-on and add it to the collection of add-ons.
         * @param {AddOn} [addOn] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AddonsPost: async (addOn?: AddOn, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/addons`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addOn, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the aws infrastructure access role.
         * @param {string} [awsInfrastructureAccessRoleId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AwsInfrastructureAccessRolesAwsInfrastructureAccessRoleIdGet: async (awsInfrastructureAccessRoleId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/aws_infrastructure_access_roles/{aws_infrastructure_access_role_id}`
                .replace(`{${"aws_infrastructure_access_role_id"}}`, encodeURIComponent(String(awsInfrastructureAccessRoleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the role instead of the names of the columns of a table. For example, in order to sort the roles descending by dislay_name the value should be:  &#x60;&#x60;&#x60;sql display_name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the role instead of the names of the columns of a table. For example, in order to retrieve all the role with a name starting with &#x60;my&#x60;the value should be:  &#x60;&#x60;&#x60;sql display_name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the roles that the user has permission to see will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AwsInfrastructureAccessRolesGet: async (order?: string, page?: number, search?: string, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/aws_infrastructure_access_roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of machine types in the provided region.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {CloudProviderData} [cloudProviderData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AwsInquiriesMachineTypesPost: async (page?: number, size?: number, cloudProviderData?: CloudProviderData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/aws_inquiries/machine_types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cloudProviderData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of available regions of the cloud provider. IMPORTANT: This list doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of available regions of the provider.
         * @param {number} [page] Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;.
         * @param {number} [size] Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of regions of the provider.
         * @param {CloudProviderData} [cloudProviderData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AwsInquiriesRegionsPost: async (page?: number, size?: number, cloudProviderData?: CloudProviderData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/aws_inquiries/regions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cloudProviderData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of policies.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AwsInquiriesStsCredentialRequestsGet: async (page?: number, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/aws_inquiries/sts_credential_requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of policies.
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the awsstspolicies instead of the names of the columns of a table. For example, in order to sort the policies descending by operator type identifier the value should be:  &#x60;&#x60;&#x60;sql orderBy id desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the awsstspolicies instead of the names of the columns of a table. For example, in order to retrieve all the policies of type  &#x60;operatorrole&#x60; should be:  &#x60;&#x60;&#x60;sql policy_type like \&#39;OperatorRole%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the policies  will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AwsInquiriesStsPoliciesGet: async (order?: string, page?: number, search?: string, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/aws_inquiries/sts_policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of available vpcs of the cloud provider for specific region. IMPORTANT: This collection doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of available vpcs of the provider.
         * @param {number} [page] Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;.
         * @param {number} [size] Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of vpcs of the provider.
         * @param {CloudProviderData} [cloudProviderData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AwsInquiriesVpcsPost: async (page?: number, size?: number, cloudProviderData?: CloudProviderData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/aws_inquiries/vpcs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cloudProviderData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of available regions of the cloud provider.  IMPORTANT: This collection doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of available regions of the provider.
         * @param {string} [cloudProviderId] 
         * @param {number} [page] Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;.
         * @param {number} [size] Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of regions of the provider.
         * @param {AWS} [aWS] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1CloudProvidersCloudProviderIdAvailableRegionsPost: async (cloudProviderId?: string, page?: number, size?: number, aWS?: AWS, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/cloud_providers/{cloud_provider_id}/available_regions`
                .replace(`{${"cloud_provider_id"}}`, encodeURIComponent(String(cloudProviderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(aWS, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the cloud provider.
         * @param {string} [cloudProviderId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1CloudProvidersCloudProviderIdGet: async (cloudProviderId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/cloud_providers/{cloud_provider_id}`
                .replace(`{${"cloud_provider_id"}}`, encodeURIComponent(String(cloudProviderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of regions of the cloud provider.  IMPORTANT: This collection doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of regions of the provider.
         * @param {string} [cloudProviderId] 
         * @param {number} [page] Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;.
         * @param {number} [size] Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of regions of the provider.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsGet: async (cloudProviderId?: string, page?: number, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/cloud_providers/{cloud_provider_id}/regions`
                .replace(`{${"cloud_provider_id"}}`, encodeURIComponent(String(cloudProviderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the region.
         * @param {string} [cloudProviderId] 
         * @param {string} [regionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsRegionIdGet: async (cloudProviderId?: string, regionId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/cloud_providers/{cloud_provider_id}/regions/{region_id}`
                .replace(`{${"cloud_provider_id"}}`, encodeURIComponent(String(cloudProviderId)))
                .replace(`{${"region_id"}}`, encodeURIComponent(String(regionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of cloud providers.
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the cloud provider instead of the names of the columns of a table. For example, in order to sort the clusters descending by name identifier the value should be:  &#x60;&#x60;&#x60;sql name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the cloud provider instead of the names of the columns of a table. For example, in order to retrieve all the cloud providers with a name starting with &#x60;A&#x60; the value should be:  &#x60;&#x60;&#x60;sql name like \&#39;A%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the clusters that the user has permission to see will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1CloudProvidersGet: async (order?: string, page?: number, search?: string, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/cloud_providers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [clusterId] 
         * @param {string} [addonInquiryId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAddonInquiriesAddonInquiryIdGet: async (clusterId?: string, addonInquiryId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/addon_inquiries/{addon_inquiry_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"addon_inquiry_id"}}`, encodeURIComponent(String(addonInquiryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [clusterId] 
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the add-on instead of the names of the columns of a table. For example, in order to sort the add-ons descending by name the value should be:  &#x60;&#x60;&#x60;sql name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the add-on instead of the names of the columns of a table. For example, in order to retrieve all the add-ons with a name starting with &#x60;my&#x60; the value should be:  &#x60;&#x60;&#x60;sql name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the add-ons that the user has permission to see will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAddonInquiriesGet: async (clusterId?: string, order?: string, page?: number, search?: string, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/addon_inquiries`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an add-on installation and remove it from the collection of add-on installations on the cluster.
         * @param {string} [clusterId] 
         * @param {string} [addoninstallationId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdDelete: async (clusterId?: string, addoninstallationId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/addons/{addoninstallation_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"addoninstallation_id"}}`, encodeURIComponent(String(addoninstallationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the add-on installation.
         * @param {string} [clusterId] 
         * @param {string} [addoninstallationId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdGet: async (clusterId?: string, addoninstallationId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/addons/{addoninstallation_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"addoninstallation_id"}}`, encodeURIComponent(String(addoninstallationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the add-on installation.
         * @param {string} [clusterId] 
         * @param {string} [addoninstallationId] 
         * @param {AddOnInstallation} [addOnInstallation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdPatch: async (clusterId?: string, addoninstallationId?: string, addOnInstallation?: AddOnInstallation, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/addons/{addoninstallation_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"addoninstallation_id"}}`, encodeURIComponent(String(addoninstallationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addOnInstallation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of add-on installations.
         * @param {string} [clusterId] 
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the add-on installation instead of the names of the columns of a table. For example, in order to sort the add-on installations descending by name the value should be:  &#x60;&#x60;&#x60;sql name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the add-on installation instead of the names of the columns of a table. For example, in order to retrieve all the add-on installations with a name starting with &#x60;my&#x60; the value should be:  &#x60;&#x60;&#x60;sql name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the add-on installations that the user has permission to see will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAddonsGet: async (clusterId?: string, order?: string, page?: number, search?: string, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/addons`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new add-on installation and add it to the collection of add-on installations on the cluster.
         * @param {string} [clusterId] 
         * @param {AddOnInstallation} [addOnInstallation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAddonsPost: async (clusterId?: string, addOnInstallation?: AddOnInstallation, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/addons`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addOnInstallation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the AWS infrastructure access role grant.
         * @param {string} [clusterId] 
         * @param {string} [awsInfrastructureAccessRoleGrantId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsAwsInfrastructureAccessRoleGrantIdDelete: async (clusterId?: string, awsInfrastructureAccessRoleGrantId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/aws_infrastructure_access_role_grants/{aws_infrastructure_access_role_grant_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"aws_infrastructure_access_role_grant_id"}}`, encodeURIComponent(String(awsInfrastructureAccessRoleGrantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the AWS infrastructure access role grant.
         * @param {string} [clusterId] 
         * @param {string} [awsInfrastructureAccessRoleGrantId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsAwsInfrastructureAccessRoleGrantIdGet: async (clusterId?: string, awsInfrastructureAccessRoleGrantId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/aws_infrastructure_access_role_grants/{aws_infrastructure_access_role_grant_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"aws_infrastructure_access_role_grant_id"}}`, encodeURIComponent(String(awsInfrastructureAccessRoleGrantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of AWS infrastructure access role grants.
         * @param {string} [clusterId] 
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the AWS infrastructure access role grant instead of the names of the columns of a table. For example, in order to sort the AWS infrastructure access role grants descending by user ARN the value should be:  &#x60;&#x60;&#x60;sql user_arn desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the AWS infrastructure access role grant instead of the names of the columns of a table. For example, in order to retrieve all the AWS infrastructure access role grants with a user ARN starting with &#x60;user&#x60; the value should be:  &#x60;&#x60;&#x60;sql user_arn like \&#39;%user\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the AWS infrastructure access role grants that the user has permission to see will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsGet: async (clusterId?: string, order?: string, page?: number, search?: string, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/aws_infrastructure_access_role_grants`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new AWS infrastructure access role grant and add it to the collection of AWS infrastructure access role grants on the cluster.
         * @param {string} [clusterId] 
         * @param {AWSInfrastructureAccessRoleGrant} [aWSInfrastructureAccessRoleGrant] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsPost: async (clusterId?: string, aWSInfrastructureAccessRoleGrant?: AWSInfrastructureAccessRoleGrant, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/aws_infrastructure_access_role_grants`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(aWSInfrastructureAccessRoleGrant, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the clusterdeployment.
         * @param {string} [clusterId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdClusterdeploymentDelete: async (clusterId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/clusterdeployment`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the credentials of a cluster.
         * @param {string} [clusterId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdCredentialsGet: async (clusterId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/credentials`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the cluster.
         * @param {string} [clusterId] 
         * @param {boolean} [deprovision] If false it will only delete from OCM but not the actual cluster resources. false is only allowed for OCP clusters. true by default.
         * @param {boolean} [dryRun] Dry run flag is used to check if the operation can be completed, but won\&#39;t delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdDelete: async (clusterId?: string, deprovision?: boolean, dryRun?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (deprovision !== undefined) {
                localVarQueryParameter['deprovision'] = deprovision;
            }

            if (dryRun !== undefined) {
                localVarQueryParameter['dry_run'] = dryRun;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the external configuration.
         * @param {string} [clusterId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationGet: async (clusterId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/external_configuration`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of labels.
         * @param {string} [clusterId] 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsGet: async (clusterId?: string, page?: number, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/external_configuration/labels`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the label.
         * @param {string} [clusterId] 
         * @param {string} [labelId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdDelete: async (clusterId?: string, labelId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/external_configuration/labels/{label_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"label_id"}}`, encodeURIComponent(String(labelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the label.
         * @param {string} [clusterId] 
         * @param {string} [labelId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdGet: async (clusterId?: string, labelId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/external_configuration/labels/{label_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"label_id"}}`, encodeURIComponent(String(labelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the label.
         * @param {string} [clusterId] 
         * @param {string} [labelId] 
         * @param {Label} [label] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdPatch: async (clusterId?: string, labelId?: string, label?: Label, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/external_configuration/labels/{label_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"label_id"}}`, encodeURIComponent(String(labelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(label, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new label to the cluster.
         * @param {string} [clusterId] 
         * @param {Label} [label] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsPost: async (clusterId?: string, label?: Label, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/external_configuration/labels`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(label, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of syncsets.
         * @param {string} [clusterId] 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsGet: async (clusterId?: string, page?: number, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/external_configuration/syncsets`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new syncset to the cluster.
         * @param {string} [clusterId] 
         * @param {Syncset} [syncset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsPost: async (clusterId?: string, syncset?: Syncset, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/external_configuration/syncsets`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(syncset, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the syncset.
         * @param {string} [clusterId] 
         * @param {string} [syncsetId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdDelete: async (clusterId?: string, syncsetId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/external_configuration/syncsets/{syncset_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"syncset_id"}}`, encodeURIComponent(String(syncsetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the syncset.
         * @param {string} [clusterId] 
         * @param {string} [syncsetId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdGet: async (clusterId?: string, syncsetId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/external_configuration/syncsets/{syncset_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"syncset_id"}}`, encodeURIComponent(String(syncsetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the syncset.
         * @param {string} [clusterId] 
         * @param {string} [syncsetId] 
         * @param {Syncset} [syncset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdPatch: async (clusterId?: string, syncsetId?: string, syncset?: Syncset, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/external_configuration/syncsets/{syncset_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"syncset_id"}}`, encodeURIComponent(String(syncsetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(syncset, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of reasons.
         * @param {string} [clusterId] 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdGateAgreementsGet: async (clusterId?: string, page?: number, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/gate_agreements`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new agreed version gate to the cluster.
         * @param {string} [clusterId] 
         * @param {VersionGateAgreement} [versionGateAgreement] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdGateAgreementsPost: async (clusterId?: string, versionGateAgreement?: VersionGateAgreement, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/gate_agreements`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(versionGateAgreement, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the version gate agreement.
         * @param {string} [clusterId] 
         * @param {string} [versionGateAgreementId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdGateAgreementsVersionGateAgreementIdDelete: async (clusterId?: string, versionGateAgreementId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/gate_agreements/{version_gate_agreement_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"version_gate_agreement_id"}}`, encodeURIComponent(String(versionGateAgreementId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the version gate agreement.
         * @param {string} [clusterId] 
         * @param {string} [versionGateAgreementId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdGateAgreementsVersionGateAgreementIdGet: async (clusterId?: string, versionGateAgreementId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/gate_agreements/{version_gate_agreement_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"version_gate_agreement_id"}}`, encodeURIComponent(String(versionGateAgreementId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the cluster.
         * @param {string} [clusterId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdGet: async (clusterId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of groups.
         * @param {string} [clusterId] 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdGroupsGet: async (clusterId?: string, page?: number, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/groups`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the group.
         * @param {string} [clusterId] 
         * @param {string} [groupId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdGroupsGroupIdGet: async (clusterId?: string, groupId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/groups/{group_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of users.
         * @param {string} [clusterId] 
         * @param {string} [groupId] 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersGet: async (clusterId?: string, groupId?: string, page?: number, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/groups/{group_id}/users`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new user to the group.
         * @param {string} [clusterId] 
         * @param {string} [groupId] 
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersPost: async (clusterId?: string, groupId?: string, user?: User, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/groups/{group_id}/users`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the user.
         * @param {string} [clusterId] 
         * @param {string} [groupId] 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdDelete: async (clusterId?: string, groupId?: string, userId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/groups/{group_id}/users/{user_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the user.
         * @param {string} [clusterId] 
         * @param {string} [groupId] 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdGet: async (clusterId?: string, groupId?: string, userId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/groups/{group_id}/users/{user_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Initiates cluster hibernation. While hibernating a cluster will not consume any cloud provider infrastructure but will be counted for quota.
         * @param {string} [clusterId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdHibernatePost: async (clusterId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/hibernate`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of identity providers.
         * @param {string} [clusterId] 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIdentityProvidersGet: async (clusterId?: string, page?: number, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/identity_providers`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the identity provider.
         * @param {string} [clusterId] 
         * @param {string} [identityProviderId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdDelete: async (clusterId?: string, identityProviderId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/identity_providers/{identity_provider_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"identity_provider_id"}}`, encodeURIComponent(String(identityProviderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the identity provider.
         * @param {string} [clusterId] 
         * @param {string} [identityProviderId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdGet: async (clusterId?: string, identityProviderId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/identity_providers/{identity_provider_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"identity_provider_id"}}`, encodeURIComponent(String(identityProviderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of _HTPasswd_ IDP users.
         * @param {string} [clusterId] 
         * @param {string} [identityProviderId] 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersGet: async (clusterId?: string, identityProviderId?: string, page?: number, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/identity_providers/{identity_provider_id}/htpasswd_users`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"identity_provider_id"}}`, encodeURIComponent(String(identityProviderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the user.
         * @param {string} [clusterId] 
         * @param {string} [identityProviderId] 
         * @param {string} [htpasswdUserId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdDelete: async (clusterId?: string, identityProviderId?: string, htpasswdUserId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/identity_providers/{identity_provider_id}/htpasswd_users/{htpasswd_user_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"identity_provider_id"}}`, encodeURIComponent(String(identityProviderId)))
                .replace(`{${"htpasswd_user_id"}}`, encodeURIComponent(String(htpasswdUserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the user.
         * @param {string} [clusterId] 
         * @param {string} [identityProviderId] 
         * @param {string} [htpasswdUserId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdGet: async (clusterId?: string, identityProviderId?: string, htpasswdUserId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/identity_providers/{identity_provider_id}/htpasswd_users/{htpasswd_user_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"identity_provider_id"}}`, encodeURIComponent(String(identityProviderId)))
                .replace(`{${"htpasswd_user_id"}}`, encodeURIComponent(String(htpasswdUserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the user\'s password. The username is not editable
         * @param {string} [clusterId] 
         * @param {string} [identityProviderId] 
         * @param {string} [htpasswdUserId] 
         * @param {HTPasswdUser} [hTPasswdUser] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdPatch: async (clusterId?: string, identityProviderId?: string, htpasswdUserId?: string, hTPasswdUser?: HTPasswdUser, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/identity_providers/{identity_provider_id}/htpasswd_users/{htpasswd_user_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"identity_provider_id"}}`, encodeURIComponent(String(identityProviderId)))
                .replace(`{${"htpasswd_user_id"}}`, encodeURIComponent(String(htpasswdUserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(hTPasswdUser, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds multiple new users to the _HTPasswd_ file.
         * @param {string} [clusterId] 
         * @param {string} [identityProviderId] 
         * @param {InlineObject} [inlineObject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersImportPost: async (clusterId?: string, identityProviderId?: string, inlineObject?: InlineObject, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/identity_providers/{identity_provider_id}/htpasswd_users/import`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"identity_provider_id"}}`, encodeURIComponent(String(identityProviderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new user to the _HTPasswd_ file.
         * @param {string} [clusterId] 
         * @param {string} [identityProviderId] 
         * @param {HTPasswdUser} [hTPasswdUser] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersPost: async (clusterId?: string, identityProviderId?: string, hTPasswdUser?: HTPasswdUser, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/identity_providers/{identity_provider_id}/htpasswd_users`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"identity_provider_id"}}`, encodeURIComponent(String(identityProviderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(hTPasswdUser, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update identity provider in the cluster.
         * @param {string} [clusterId] 
         * @param {string} [identityProviderId] 
         * @param {IdentityProvider} [identityProvider] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdPatch: async (clusterId?: string, identityProviderId?: string, identityProvider?: IdentityProvider, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/identity_providers/{identity_provider_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"identity_provider_id"}}`, encodeURIComponent(String(identityProviderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(identityProvider, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new identity provider to the cluster.
         * @param {string} [clusterId] 
         * @param {IdentityProvider} [identityProvider] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIdentityProvidersPost: async (clusterId?: string, identityProvider?: IdentityProvider, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/identity_providers`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(identityProvider, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of ingresses.
         * @param {string} [clusterId] 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIngressesGet: async (clusterId?: string, page?: number, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/ingresses`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the ingress.
         * @param {string} [clusterId] 
         * @param {string} [ingressId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIngressesIngressIdDelete: async (clusterId?: string, ingressId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/ingresses/{ingress_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"ingress_id"}}`, encodeURIComponent(String(ingressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the ingress.
         * @param {string} [clusterId] 
         * @param {string} [ingressId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIngressesIngressIdGet: async (clusterId?: string, ingressId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/ingresses/{ingress_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"ingress_id"}}`, encodeURIComponent(String(ingressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the ingress.
         * @param {string} [clusterId] 
         * @param {string} [ingressId] 
         * @param {Ingress} [ingress] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIngressesIngressIdPatch: async (clusterId?: string, ingressId?: string, ingress?: Ingress, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/ingresses/{ingress_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"ingress_id"}}`, encodeURIComponent(String(ingressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ingress, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates all ingresses
         * @param {string} [clusterId] 
         * @param {Array<Ingress>} [ingress] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIngressesPatch: async (clusterId?: string, ingress?: Array<Ingress>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/ingresses`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ingress, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new ingress to the cluster.
         * @param {string} [clusterId] 
         * @param {Ingress} [ingress] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIngressesPost: async (clusterId?: string, ingress?: Ingress, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/ingresses`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ingress, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of reasons.
         * @param {string} [clusterId] 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsGet: async (clusterId?: string, page?: number, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/limited_support_reasons`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the reason.
         * @param {string} [clusterId] 
         * @param {string} [limitedSupportReasonId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsLimitedSupportReasonIdDelete: async (clusterId?: string, limitedSupportReasonId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/limited_support_reasons/{limited_support_reason_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"limited_support_reason_id"}}`, encodeURIComponent(String(limitedSupportReasonId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the reason.
         * @param {string} [clusterId] 
         * @param {string} [limitedSupportReasonId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsLimitedSupportReasonIdGet: async (clusterId?: string, limitedSupportReasonId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/limited_support_reasons/{limited_support_reason_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"limited_support_reason_id"}}`, encodeURIComponent(String(limitedSupportReasonId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new reason to the cluster.
         * @param {string} [clusterId] 
         * @param {LimitedSupportReason} [limitedSupportReason] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsPost: async (clusterId?: string, limitedSupportReason?: LimitedSupportReason, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/limited_support_reasons`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(limitedSupportReason, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of log links.
         * @param {string} [clusterId] 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdLogsGet: async (clusterId?: string, page?: number, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/logs`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the log.
         * @param {string} [clusterId] 
         * @param {number} [offset] Line offset to start logs from. if 0 retreive entire log. If offset &gt; #lines return an empty log.
         * @param {number} [tail] Returns the number of tail lines from the end of the log. If there are no line breaks or the number of lines &lt; tail return the entire log. Either \&#39;tail\&#39; or \&#39;offset\&#39; can be set. Not both. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdLogsInstallGet: async (clusterId?: string, offset?: number, tail?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/logs/install`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (tail !== undefined) {
                localVarQueryParameter['tail'] = tail;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the log.
         * @param {string} [clusterId] 
         * @param {number} [offset] Line offset to start logs from. if 0 retreive entire log. If offset &gt; #lines return an empty log.
         * @param {number} [tail] Returns the number of tail lines from the end of the log. If there are no line breaks or the number of lines &lt; tail return the entire log. Either \&#39;tail\&#39; or \&#39;offset\&#39; can be set. Not both. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdLogsUninstallGet: async (clusterId?: string, offset?: number, tail?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/logs/uninstall`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (tail !== undefined) {
                localVarQueryParameter['tail'] = tail;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of machine pools.
         * @param {string} [clusterId] 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdMachinePoolsGet: async (clusterId?: string, page?: number, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/machine_pools`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the machine pool.
         * @param {string} [clusterId] 
         * @param {string} [machinePoolId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdDelete: async (clusterId?: string, machinePoolId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/machine_pools/{machine_pool_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"machine_pool_id"}}`, encodeURIComponent(String(machinePoolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the machine pool.
         * @param {string} [clusterId] 
         * @param {string} [machinePoolId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdGet: async (clusterId?: string, machinePoolId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/machine_pools/{machine_pool_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"machine_pool_id"}}`, encodeURIComponent(String(machinePoolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the machine pool.
         * @param {string} [clusterId] 
         * @param {string} [machinePoolId] 
         * @param {MachinePool} [machinePool] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdPatch: async (clusterId?: string, machinePoolId?: string, machinePool?: MachinePool, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/machine_pools/{machine_pool_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"machine_pool_id"}}`, encodeURIComponent(String(machinePoolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(machinePool, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new machine pool to the cluster.
         * @param {string} [clusterId] 
         * @param {MachinePool} [machinePool] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdMachinePoolsPost: async (clusterId?: string, machinePool?: MachinePool, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/machine_pools`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(machinePool, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [clusterId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdMetricQueriesAlertsGet: async (clusterId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/metric_queries/alerts`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [clusterId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdMetricQueriesClusterOperatorsGet: async (clusterId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/metric_queries/cluster_operators`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the metrics.
         * @param {string} [clusterId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdMetricQueriesCpuTotalByNodeRolesOsGet: async (clusterId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/metric_queries/cpu_total_by_node_roles_os`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [clusterId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdMetricQueriesNodesGet: async (clusterId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/metric_queries/nodes`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the metrics.
         * @param {string} [clusterId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdMetricQueriesSocketTotalByNodeRolesOsGet: async (clusterId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/metric_queries/socket_total_by_node_roles_os`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the cluster.
         * @param {string} [clusterId] 
         * @param {Cluster} [cluster] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdPatch: async (clusterId?: string, cluster?: Cluster, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cluster, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the product.
         * @param {string} [clusterId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdProductGet: async (clusterId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/product`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the provision shard.
         * @param {string} [clusterId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdProvisionShardGet: async (clusterId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/provision_shard`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of resources for a cluster in error state
         * @param {string} [clusterId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdResourcesGet: async (clusterId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/resources`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves currently available cluster resources
         * @param {string} [clusterId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdResourcesLiveGet: async (clusterId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/resources/live`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resumes from Hibernation.
         * @param {string} [clusterId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdResumePost: async (clusterId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/resume`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [clusterId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdStatusGet: async (clusterId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/status`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of operator roles.
         * @param {string} [clusterId] 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdStsOperatorRolesGet: async (clusterId?: string, page?: number, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/sts_operator_roles`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the operator role.
         * @param {string} [clusterId] 
         * @param {string} [operatorIamRoleId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdStsOperatorRolesOperatorIamRoleIdDelete: async (clusterId?: string, operatorIamRoleId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/sts_operator_roles/{operator_iam_role_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"operator_iam_role_id"}}`, encodeURIComponent(String(operatorIamRoleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new operator role to the cluster.
         * @param {string} [clusterId] 
         * @param {OperatorIAMRole} [operatorIAMRole] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdStsOperatorRolesPost: async (clusterId?: string, operatorIAMRole?: OperatorIAMRole, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/sts_operator_roles`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(operatorIAMRole, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of upgrade policies.
         * @param {string} [clusterId] 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdUpgradePoliciesGet: async (clusterId?: string, page?: number, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/upgrade_policies`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new upgrade policy to the cluster.
         * @param {string} [clusterId] 
         * @param {UpgradePolicy} [upgradePolicy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdUpgradePoliciesPost: async (clusterId?: string, upgradePolicy?: UpgradePolicy, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/upgrade_policies`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(upgradePolicy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the upgrade policy.
         * @param {string} [clusterId] 
         * @param {string} [upgradePolicyId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdDelete: async (clusterId?: string, upgradePolicyId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/upgrade_policies/{upgrade_policy_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"upgrade_policy_id"}}`, encodeURIComponent(String(upgradePolicyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the upgrade policy.
         * @param {string} [clusterId] 
         * @param {string} [upgradePolicyId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdGet: async (clusterId?: string, upgradePolicyId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/upgrade_policies/{upgrade_policy_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"upgrade_policy_id"}}`, encodeURIComponent(String(upgradePolicyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the upgrade policy.
         * @param {string} [clusterId] 
         * @param {string} [upgradePolicyId] 
         * @param {UpgradePolicy} [upgradePolicy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdPatch: async (clusterId?: string, upgradePolicyId?: string, upgradePolicy?: UpgradePolicy, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/upgrade_policies/{upgrade_policy_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"upgrade_policy_id"}}`, encodeURIComponent(String(upgradePolicyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(upgradePolicy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the upgrade policy state.
         * @param {string} [clusterId] 
         * @param {string} [upgradePolicyId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdStateGet: async (clusterId?: string, upgradePolicyId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/upgrade_policies/{upgrade_policy_id}/state`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"upgrade_policy_id"}}`, encodeURIComponent(String(upgradePolicyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the upgrade policy state.
         * @param {string} [clusterId] 
         * @param {string} [upgradePolicyId] 
         * @param {UpgradePolicyState} [upgradePolicyState] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdStatePatch: async (clusterId?: string, upgradePolicyId?: string, upgradePolicyState?: UpgradePolicyState, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/upgrade_policies/{upgrade_policy_id}/state`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"upgrade_policy_id"}}`, encodeURIComponent(String(upgradePolicyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(upgradePolicyState, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of clusters.
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the cluster instead of the names of the columns of a table. For example, in order to sort the clusters descending by region identifier the value should be:  &#x60;&#x60;&#x60;sql region.id desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the cluster instead of the names of the columns of a table. For example, in order to retrieve all the clusters with a name starting with &#x60;my&#x60; in the &#x60;us-east-1&#x60; region the value should be:  &#x60;&#x60;&#x60;sql name like \&#39;my%\&#39; and region.id &#x3D; \&#39;us-east-1\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the clusters that the user has permission to see will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersGet: async (order?: string, page?: number, search?: string, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Provision a new cluster and add it to the collection of clusters.  See the `register_cluster` method for adding an existing cluster.
         * @param {Cluster} [cluster] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersPost: async (cluster?: Cluster, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cluster, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the environment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1EnvironmentGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/environment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the environment.  Attributes that can be updated are:  - `last_upgrade_available_check` - `last_limited_support_check`
         * @param {Environment} [environment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1EnvironmentPatch: async (environment?: Environment, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/environment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environment, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new event to be tracked. When sending a new event request, it gets tracked in Prometheus, Pendo, CloudWatch, or whichever analytics client is configured as part of clusters service. This allows for reporting on events that happen outside of a regular API request, but are found to be useful for understanding customer needs and possible blockers.
         * @param {Event} [event] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1EventsPost: async (event?: Event, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(event, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the cluster flavour.
         * @param {string} [flavourId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1FlavoursFlavourIdGet: async (flavourId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/flavours/{flavour_id}`
                .replace(`{${"flavour_id"}}`, encodeURIComponent(String(flavourId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the flavour.  Attributes that can be updated are:  - `aws.infra_volume` - `aws.infra_instance_type` - `gcp.infra_instance_type`
         * @param {string} [flavourId] 
         * @param {Flavour} [flavour] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1FlavoursFlavourIdPatch: async (flavourId?: string, flavour?: Flavour, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/flavours/{flavour_id}`
                .replace(`{${"flavour_id"}}`, encodeURIComponent(String(flavourId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flavour, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the flavour instead of the names of the columns of a table. For example, in order to sort the flavours descending by name the value should be:  &#x60;&#x60;&#x60;sql name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the flavour instead of the names of the columns of a table. For example, in order to retrieve all the flavours with a name starting with &#x60;my&#x60;the value should be:  &#x60;&#x60;&#x60;sql name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the flavours that the user has permission to see will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1FlavoursGet: async (order?: string, page?: number, search?: string, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/flavours`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new cluster flavour.
         * @param {Flavour} [flavour] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1FlavoursPost: async (flavour?: Flavour, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/flavours`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flavour, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of encryption keys. IMPORTANT: This collection doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of available regions of the provider.
         * @param {number} [page] Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;.
         * @param {number} [size] Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of regions of the provider.
         * @param {CloudProviderData} [cloudProviderData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1GcpInquiriesEncryptionKeysPost: async (page?: number, size?: number, cloudProviderData?: CloudProviderData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/gcp_inquiries/encryption_keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cloudProviderData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of available key rings of the cloud provider. IMPORTANT: This collection doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of available regions of the provider.
         * @param {number} [page] Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;.
         * @param {number} [size] Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of key rings of the provider.
         * @param {CloudProviderData} [cloudProviderData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1GcpInquiriesKeyRingsPost: async (page?: number, size?: number, cloudProviderData?: CloudProviderData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/gcp_inquiries/key_rings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cloudProviderData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of available regions of the cloud provider. IMPORTANT: This list doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of available regions of the provider.
         * @param {number} [page] Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;.
         * @param {number} [size] Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of regions of the provider.
         * @param {CloudProviderData} [cloudProviderData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1GcpInquiriesRegionsPost: async (page?: number, size?: number, cloudProviderData?: CloudProviderData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/gcp_inquiries/regions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cloudProviderData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of available vpcs of the cloud provider for specific region. IMPORTANT: This collection doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of available vpcs of the provider.
         * @param {number} [page] Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;.
         * @param {number} [size] Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of vpcs of the provider.
         * @param {CloudProviderData} [cloudProviderData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1GcpInquiriesVpcsPost: async (page?: number, size?: number, cloudProviderData?: CloudProviderData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/gcp_inquiries/vpcs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cloudProviderData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the version metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1Get: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of templates.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1LimitedSupportReasonTemplatesGet: async (page?: number, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/limited_support_reason_templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the template.
         * @param {string} [limitedSupportReasonTemplateId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1LimitedSupportReasonTemplatesLimitedSupportReasonTemplateIdGet: async (limitedSupportReasonTemplateId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/limited_support_reason_templates/{limited_support_reason_template_id}`
                .replace(`{${"limited_support_reason_template_id"}}`, encodeURIComponent(String(limitedSupportReasonTemplateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of machine types.
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the machine type instead of the names of the columns of a table. For example, in order to sort the machine types descending by name identifier the value should be:  &#x60;&#x60;&#x60;sql name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the machine type instead of the names of the columns of a table. For example, in order to retrieve all the machine types with a name starting with &#x60;A&#x60; the value should be:  &#x60;&#x60;&#x60;sql name like \&#39;A%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the machine types that the user has permission to see will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1MachineTypesGet: async (order?: string, page?: number, search?: string, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/machine_types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of products.
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the product instead of the names of the columns of a table. For example, in order to sort the products descending by name the value should be:  &#x60;&#x60;&#x60;sql name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the product instead of the names of the columns of a table. For example, in order to retrieve all the products with a name starting with &#x60;my&#x60; the value should be:  &#x60;&#x60;&#x60;sql name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the products that the user has permission to see will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ProductsGet: async (order?: string, page?: number, search?: string, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the product.
         * @param {string} [productId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ProductsProductIdGet: async (productId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/products/{product_id}`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ProvisionShardsGet: async (page?: number, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/provision_shards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the provision shard.
         * @param {string} [provisionShardId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ProvisionShardsProvisionShardIdGet: async (provisionShardId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/provision_shards/{provision_shard_id}`
                .replace(`{${"provision_shard_id"}}`, encodeURIComponent(String(provisionShardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of version gates.
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of an SQL statement, but using the names of the attributes of the version gate instead of the names of the columns of a table. For example, in order to sort the version gates descending by identifier the value should be:  &#x60;&#x60;&#x60;sql id desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the version gate instead of the names of the columns of a table.  If the parameter isn\&#39;t provided, or if the value is empty, then all the version gates that the user has permission to see will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.  Default value is &#x60;100&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1VersionGatesGet: async (order?: string, page?: number, search?: string, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/version_gates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new version gate
         * @param {VersionGate} [versionGate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1VersionGatesPost: async (versionGate?: VersionGate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/version_gates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(versionGate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the version gate.
         * @param {string} [versionGateId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1VersionGatesVersionGateIdDelete: async (versionGateId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/version_gates/{version_gate_id}`
                .replace(`{${"version_gate_id"}}`, encodeURIComponent(String(versionGateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the version gate.
         * @param {string} [versionGateId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1VersionGatesVersionGateIdGet: async (versionGateId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/version_gates/{version_gate_id}`
                .replace(`{${"version_gate_id"}}`, encodeURIComponent(String(versionGateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of versions.
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the version instead of the names of the columns of a table. For example, in order to sort the versions descending by identifier the value should be:  &#x60;&#x60;&#x60;sql id desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the version instead of the names of the columns of a table. For example, in order to retrieve all the versions that are enabled:  &#x60;&#x60;&#x60;sql enabled &#x3D; \&#39;t\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the versions that the user has permission to see will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.  Default value is &#x60;100&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1VersionsGet: async (order?: string, page?: number, search?: string, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/versions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the version.
         * @param {string} [versionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1VersionsVersionIdGet: async (versionId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/versions/{version_id}`
                .replace(`{${"version_id"}}`, encodeURIComponent(String(versionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes the add-on.
         * @param {string} [addonId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1AddonsAddonIdDelete(addonId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1AddonsAddonIdDelete(addonId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the add-on.
         * @param {string} [addonId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1AddonsAddonIdGet(addonId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddOn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1AddonsAddonIdGet(addonId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the add-on.
         * @param {string} [addonId] 
         * @param {AddOn} [addOn] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1AddonsAddonIdPatch(addonId?: string, addOn?: AddOn, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddOn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1AddonsAddonIdPatch(addonId, addOn, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of add-on versions.
         * @param {string} [addonId] 
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the add-on instead of the names of the columns of a table. For example, in order to sort the add-on versions descending by id the value should be:  &#x60;&#x60;&#x60;sql id desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the add-on version instead of the names of the columns of a table. For example, in order to retrieve all the add-on versions with an id starting with &#x60;0.1&#x60; the value should be:  &#x60;&#x60;&#x60;sql id like \&#39;0.1.%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the add-on versions that the user has permission to see will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1AddonsAddonIdVersionsGet(addonId?: string, order?: string, page?: number, search?: string, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1AddonsAddonIdVersionsGet(addonId, order, page, search, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new add-on version and add it to the collection of add-ons.
         * @param {string} [addonId] 
         * @param {AddOnVersion} [addOnVersion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1AddonsAddonIdVersionsPost(addonId?: string, addOnVersion?: AddOnVersion, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddOnVersion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1AddonsAddonIdVersionsPost(addonId, addOnVersion, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the add-on version.
         * @param {string} [addonId] 
         * @param {string} [versionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1AddonsAddonIdVersionsVersionIdDelete(addonId?: string, versionId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1AddonsAddonIdVersionsVersionIdDelete(addonId, versionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the add-on version.
         * @param {string} [addonId] 
         * @param {string} [versionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1AddonsAddonIdVersionsVersionIdGet(addonId?: string, versionId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddOnVersion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1AddonsAddonIdVersionsVersionIdGet(addonId, versionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the add-on version.
         * @param {string} [addonId] 
         * @param {string} [versionId] 
         * @param {AddOnVersion} [addOnVersion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1AddonsAddonIdVersionsVersionIdPatch(addonId?: string, versionId?: string, addOnVersion?: AddOnVersion, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddOnVersion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1AddonsAddonIdVersionsVersionIdPatch(addonId, versionId, addOnVersion, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of add-ons.
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the add-on instead of the names of the columns of a table. For example, in order to sort the add-ons descending by name the value should be:  &#x60;&#x60;&#x60;sql name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the add-on instead of the names of the columns of a table. For example, in order to retrieve all the add-ons with a name starting with &#x60;my&#x60; the value should be:  &#x60;&#x60;&#x60;sql name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the add-ons that the user has permission to see will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1AddonsGet(order?: string, page?: number, search?: string, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1AddonsGet(order, page, search, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new add-on and add it to the collection of add-ons.
         * @param {AddOn} [addOn] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1AddonsPost(addOn?: AddOn, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddOn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1AddonsPost(addOn, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the aws infrastructure access role.
         * @param {string} [awsInfrastructureAccessRoleId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1AwsInfrastructureAccessRolesAwsInfrastructureAccessRoleIdGet(awsInfrastructureAccessRoleId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AWSInfrastructureAccessRole>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1AwsInfrastructureAccessRolesAwsInfrastructureAccessRoleIdGet(awsInfrastructureAccessRoleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the role instead of the names of the columns of a table. For example, in order to sort the roles descending by dislay_name the value should be:  &#x60;&#x60;&#x60;sql display_name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the role instead of the names of the columns of a table. For example, in order to retrieve all the role with a name starting with &#x60;my&#x60;the value should be:  &#x60;&#x60;&#x60;sql display_name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the roles that the user has permission to see will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1AwsInfrastructureAccessRolesGet(order?: string, page?: number, search?: string, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1AwsInfrastructureAccessRolesGet(order, page, search, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of machine types in the provided region.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {CloudProviderData} [cloudProviderData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1AwsInquiriesMachineTypesPost(page?: number, size?: number, cloudProviderData?: CloudProviderData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2003>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1AwsInquiriesMachineTypesPost(page, size, cloudProviderData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of available regions of the cloud provider. IMPORTANT: This list doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of available regions of the provider.
         * @param {number} [page] Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;.
         * @param {number} [size] Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of regions of the provider.
         * @param {CloudProviderData} [cloudProviderData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1AwsInquiriesRegionsPost(page?: number, size?: number, cloudProviderData?: CloudProviderData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1AwsInquiriesRegionsPost(page, size, cloudProviderData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of policies.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1AwsInquiriesStsCredentialRequestsGet(page?: number, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2005>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1AwsInquiriesStsCredentialRequestsGet(page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of policies.
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the awsstspolicies instead of the names of the columns of a table. For example, in order to sort the policies descending by operator type identifier the value should be:  &#x60;&#x60;&#x60;sql orderBy id desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the awsstspolicies instead of the names of the columns of a table. For example, in order to retrieve all the policies of type  &#x60;operatorrole&#x60; should be:  &#x60;&#x60;&#x60;sql policy_type like \&#39;OperatorRole%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the policies  will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1AwsInquiriesStsPoliciesGet(order?: string, page?: number, search?: string, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2006>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1AwsInquiriesStsPoliciesGet(order, page, search, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of available vpcs of the cloud provider for specific region. IMPORTANT: This collection doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of available vpcs of the provider.
         * @param {number} [page] Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;.
         * @param {number} [size] Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of vpcs of the provider.
         * @param {CloudProviderData} [cloudProviderData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1AwsInquiriesVpcsPost(page?: number, size?: number, cloudProviderData?: CloudProviderData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2007>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1AwsInquiriesVpcsPost(page, size, cloudProviderData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of available regions of the cloud provider.  IMPORTANT: This collection doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of available regions of the provider.
         * @param {string} [cloudProviderId] 
         * @param {number} [page] Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;.
         * @param {number} [size] Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of regions of the provider.
         * @param {AWS} [aWS] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1CloudProvidersCloudProviderIdAvailableRegionsPost(cloudProviderId?: string, page?: number, size?: number, aWS?: AWS, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2009>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1CloudProvidersCloudProviderIdAvailableRegionsPost(cloudProviderId, page, size, aWS, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the cloud provider.
         * @param {string} [cloudProviderId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1CloudProvidersCloudProviderIdGet(cloudProviderId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CloudProvider>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1CloudProvidersCloudProviderIdGet(cloudProviderId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of regions of the cloud provider.  IMPORTANT: This collection doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of regions of the provider.
         * @param {string} [cloudProviderId] 
         * @param {number} [page] Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;.
         * @param {number} [size] Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of regions of the provider.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsGet(cloudProviderId?: string, page?: number, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20010>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsGet(cloudProviderId, page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the region.
         * @param {string} [cloudProviderId] 
         * @param {string} [regionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsRegionIdGet(cloudProviderId?: string, regionId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CloudRegion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsRegionIdGet(cloudProviderId, regionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of cloud providers.
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the cloud provider instead of the names of the columns of a table. For example, in order to sort the clusters descending by name identifier the value should be:  &#x60;&#x60;&#x60;sql name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the cloud provider instead of the names of the columns of a table. For example, in order to retrieve all the cloud providers with a name starting with &#x60;A&#x60; the value should be:  &#x60;&#x60;&#x60;sql name like \&#39;A%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the clusters that the user has permission to see will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1CloudProvidersGet(order?: string, page?: number, search?: string, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2008>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1CloudProvidersGet(order, page, search, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [clusterId] 
         * @param {string} [addonInquiryId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdAddonInquiriesAddonInquiryIdGet(clusterId?: string, addonInquiryId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddOn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdAddonInquiriesAddonInquiryIdGet(clusterId, addonInquiryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [clusterId] 
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the add-on instead of the names of the columns of a table. For example, in order to sort the add-ons descending by name the value should be:  &#x60;&#x60;&#x60;sql name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the add-on instead of the names of the columns of a table. For example, in order to retrieve all the add-ons with a name starting with &#x60;my&#x60; the value should be:  &#x60;&#x60;&#x60;sql name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the add-ons that the user has permission to see will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdAddonInquiriesGet(clusterId?: string, order?: string, page?: number, search?: string, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdAddonInquiriesGet(clusterId, order, page, search, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an add-on installation and remove it from the collection of add-on installations on the cluster.
         * @param {string} [clusterId] 
         * @param {string} [addoninstallationId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdDelete(clusterId?: string, addoninstallationId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdDelete(clusterId, addoninstallationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the add-on installation.
         * @param {string} [clusterId] 
         * @param {string} [addoninstallationId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdGet(clusterId?: string, addoninstallationId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddOnInstallation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdGet(clusterId, addoninstallationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the add-on installation.
         * @param {string} [clusterId] 
         * @param {string} [addoninstallationId] 
         * @param {AddOnInstallation} [addOnInstallation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdPatch(clusterId?: string, addoninstallationId?: string, addOnInstallation?: AddOnInstallation, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddOnInstallation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdPatch(clusterId, addoninstallationId, addOnInstallation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of add-on installations.
         * @param {string} [clusterId] 
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the add-on installation instead of the names of the columns of a table. For example, in order to sort the add-on installations descending by name the value should be:  &#x60;&#x60;&#x60;sql name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the add-on installation instead of the names of the columns of a table. For example, in order to retrieve all the add-on installations with a name starting with &#x60;my&#x60; the value should be:  &#x60;&#x60;&#x60;sql name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the add-on installations that the user has permission to see will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdAddonsGet(clusterId?: string, order?: string, page?: number, search?: string, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20012>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdAddonsGet(clusterId, order, page, search, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new add-on installation and add it to the collection of add-on installations on the cluster.
         * @param {string} [clusterId] 
         * @param {AddOnInstallation} [addOnInstallation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdAddonsPost(clusterId?: string, addOnInstallation?: AddOnInstallation, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddOnInstallation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdAddonsPost(clusterId, addOnInstallation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the AWS infrastructure access role grant.
         * @param {string} [clusterId] 
         * @param {string} [awsInfrastructureAccessRoleGrantId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsAwsInfrastructureAccessRoleGrantIdDelete(clusterId?: string, awsInfrastructureAccessRoleGrantId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsAwsInfrastructureAccessRoleGrantIdDelete(clusterId, awsInfrastructureAccessRoleGrantId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the AWS infrastructure access role grant.
         * @param {string} [clusterId] 
         * @param {string} [awsInfrastructureAccessRoleGrantId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsAwsInfrastructureAccessRoleGrantIdGet(clusterId?: string, awsInfrastructureAccessRoleGrantId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AWSInfrastructureAccessRoleGrant>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsAwsInfrastructureAccessRoleGrantIdGet(clusterId, awsInfrastructureAccessRoleGrantId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of AWS infrastructure access role grants.
         * @param {string} [clusterId] 
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the AWS infrastructure access role grant instead of the names of the columns of a table. For example, in order to sort the AWS infrastructure access role grants descending by user ARN the value should be:  &#x60;&#x60;&#x60;sql user_arn desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the AWS infrastructure access role grant instead of the names of the columns of a table. For example, in order to retrieve all the AWS infrastructure access role grants with a user ARN starting with &#x60;user&#x60; the value should be:  &#x60;&#x60;&#x60;sql user_arn like \&#39;%user\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the AWS infrastructure access role grants that the user has permission to see will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsGet(clusterId?: string, order?: string, page?: number, search?: string, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20013>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsGet(clusterId, order, page, search, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new AWS infrastructure access role grant and add it to the collection of AWS infrastructure access role grants on the cluster.
         * @param {string} [clusterId] 
         * @param {AWSInfrastructureAccessRoleGrant} [aWSInfrastructureAccessRoleGrant] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsPost(clusterId?: string, aWSInfrastructureAccessRoleGrant?: AWSInfrastructureAccessRoleGrant, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AWSInfrastructureAccessRoleGrant>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsPost(clusterId, aWSInfrastructureAccessRoleGrant, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the clusterdeployment.
         * @param {string} [clusterId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdClusterdeploymentDelete(clusterId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdClusterdeploymentDelete(clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the credentials of a cluster.
         * @param {string} [clusterId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdCredentialsGet(clusterId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterCredentials>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdCredentialsGet(clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the cluster.
         * @param {string} [clusterId] 
         * @param {boolean} [deprovision] If false it will only delete from OCM but not the actual cluster resources. false is only allowed for OCP clusters. true by default.
         * @param {boolean} [dryRun] Dry run flag is used to check if the operation can be completed, but won\&#39;t delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdDelete(clusterId?: string, deprovision?: boolean, dryRun?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdDelete(clusterId, deprovision, dryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the external configuration.
         * @param {string} [clusterId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdExternalConfigurationGet(clusterId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExternalConfiguration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdExternalConfigurationGet(clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of labels.
         * @param {string} [clusterId] 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsGet(clusterId?: string, page?: number, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20014>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsGet(clusterId, page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the label.
         * @param {string} [clusterId] 
         * @param {string} [labelId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdDelete(clusterId?: string, labelId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdDelete(clusterId, labelId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the label.
         * @param {string} [clusterId] 
         * @param {string} [labelId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdGet(clusterId?: string, labelId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Label>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdGet(clusterId, labelId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the label.
         * @param {string} [clusterId] 
         * @param {string} [labelId] 
         * @param {Label} [label] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdPatch(clusterId?: string, labelId?: string, label?: Label, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Label>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdPatch(clusterId, labelId, label, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a new label to the cluster.
         * @param {string} [clusterId] 
         * @param {Label} [label] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsPost(clusterId?: string, label?: Label, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Label>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsPost(clusterId, label, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of syncsets.
         * @param {string} [clusterId] 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsGet(clusterId?: string, page?: number, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20015>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsGet(clusterId, page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a new syncset to the cluster.
         * @param {string} [clusterId] 
         * @param {Syncset} [syncset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsPost(clusterId?: string, syncset?: Syncset, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Syncset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsPost(clusterId, syncset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the syncset.
         * @param {string} [clusterId] 
         * @param {string} [syncsetId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdDelete(clusterId?: string, syncsetId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdDelete(clusterId, syncsetId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the syncset.
         * @param {string} [clusterId] 
         * @param {string} [syncsetId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdGet(clusterId?: string, syncsetId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Syncset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdGet(clusterId, syncsetId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the syncset.
         * @param {string} [clusterId] 
         * @param {string} [syncsetId] 
         * @param {Syncset} [syncset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdPatch(clusterId?: string, syncsetId?: string, syncset?: Syncset, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Syncset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdPatch(clusterId, syncsetId, syncset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of reasons.
         * @param {string} [clusterId] 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdGateAgreementsGet(clusterId?: string, page?: number, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20016>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdGateAgreementsGet(clusterId, page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a new agreed version gate to the cluster.
         * @param {string} [clusterId] 
         * @param {VersionGateAgreement} [versionGateAgreement] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdGateAgreementsPost(clusterId?: string, versionGateAgreement?: VersionGateAgreement, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VersionGateAgreement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdGateAgreementsPost(clusterId, versionGateAgreement, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the version gate agreement.
         * @param {string} [clusterId] 
         * @param {string} [versionGateAgreementId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdGateAgreementsVersionGateAgreementIdDelete(clusterId?: string, versionGateAgreementId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdGateAgreementsVersionGateAgreementIdDelete(clusterId, versionGateAgreementId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the version gate agreement.
         * @param {string} [clusterId] 
         * @param {string} [versionGateAgreementId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdGateAgreementsVersionGateAgreementIdGet(clusterId?: string, versionGateAgreementId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VersionGateAgreement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdGateAgreementsVersionGateAgreementIdGet(clusterId, versionGateAgreementId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the cluster.
         * @param {string} [clusterId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdGet(clusterId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cluster>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdGet(clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of groups.
         * @param {string} [clusterId] 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdGroupsGet(clusterId?: string, page?: number, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20017>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdGroupsGet(clusterId, page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the group.
         * @param {string} [clusterId] 
         * @param {string} [groupId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdGroupsGroupIdGet(clusterId?: string, groupId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdGroupsGroupIdGet(clusterId, groupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of users.
         * @param {string} [clusterId] 
         * @param {string} [groupId] 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersGet(clusterId?: string, groupId?: string, page?: number, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20018>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersGet(clusterId, groupId, page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a new user to the group.
         * @param {string} [clusterId] 
         * @param {string} [groupId] 
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersPost(clusterId?: string, groupId?: string, user?: User, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersPost(clusterId, groupId, user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the user.
         * @param {string} [clusterId] 
         * @param {string} [groupId] 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdDelete(clusterId?: string, groupId?: string, userId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdDelete(clusterId, groupId, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the user.
         * @param {string} [clusterId] 
         * @param {string} [groupId] 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdGet(clusterId?: string, groupId?: string, userId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdGet(clusterId, groupId, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Initiates cluster hibernation. While hibernating a cluster will not consume any cloud provider infrastructure but will be counted for quota.
         * @param {string} [clusterId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdHibernatePost(clusterId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdHibernatePost(clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of identity providers.
         * @param {string} [clusterId] 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdIdentityProvidersGet(clusterId?: string, page?: number, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20019>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdIdentityProvidersGet(clusterId, page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the identity provider.
         * @param {string} [clusterId] 
         * @param {string} [identityProviderId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdDelete(clusterId?: string, identityProviderId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdDelete(clusterId, identityProviderId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the identity provider.
         * @param {string} [clusterId] 
         * @param {string} [identityProviderId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdGet(clusterId?: string, identityProviderId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentityProvider>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdGet(clusterId, identityProviderId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of _HTPasswd_ IDP users.
         * @param {string} [clusterId] 
         * @param {string} [identityProviderId] 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersGet(clusterId?: string, identityProviderId?: string, page?: number, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20020>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersGet(clusterId, identityProviderId, page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the user.
         * @param {string} [clusterId] 
         * @param {string} [identityProviderId] 
         * @param {string} [htpasswdUserId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdDelete(clusterId?: string, identityProviderId?: string, htpasswdUserId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdDelete(clusterId, identityProviderId, htpasswdUserId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the user.
         * @param {string} [clusterId] 
         * @param {string} [identityProviderId] 
         * @param {string} [htpasswdUserId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdGet(clusterId?: string, identityProviderId?: string, htpasswdUserId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HTPasswdUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdGet(clusterId, identityProviderId, htpasswdUserId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the user\'s password. The username is not editable
         * @param {string} [clusterId] 
         * @param {string} [identityProviderId] 
         * @param {string} [htpasswdUserId] 
         * @param {HTPasswdUser} [hTPasswdUser] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdPatch(clusterId?: string, identityProviderId?: string, htpasswdUserId?: string, hTPasswdUser?: HTPasswdUser, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HTPasswdUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdPatch(clusterId, identityProviderId, htpasswdUserId, hTPasswdUser, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds multiple new users to the _HTPasswd_ file.
         * @param {string} [clusterId] 
         * @param {string} [identityProviderId] 
         * @param {InlineObject} [inlineObject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersImportPost(clusterId?: string, identityProviderId?: string, inlineObject?: InlineObject, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20021>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersImportPost(clusterId, identityProviderId, inlineObject, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a new user to the _HTPasswd_ file.
         * @param {string} [clusterId] 
         * @param {string} [identityProviderId] 
         * @param {HTPasswdUser} [hTPasswdUser] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersPost(clusterId?: string, identityProviderId?: string, hTPasswdUser?: HTPasswdUser, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HTPasswdUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersPost(clusterId, identityProviderId, hTPasswdUser, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update identity provider in the cluster.
         * @param {string} [clusterId] 
         * @param {string} [identityProviderId] 
         * @param {IdentityProvider} [identityProvider] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdPatch(clusterId?: string, identityProviderId?: string, identityProvider?: IdentityProvider, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentityProvider>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdPatch(clusterId, identityProviderId, identityProvider, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a new identity provider to the cluster.
         * @param {string} [clusterId] 
         * @param {IdentityProvider} [identityProvider] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdIdentityProvidersPost(clusterId?: string, identityProvider?: IdentityProvider, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentityProvider>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdIdentityProvidersPost(clusterId, identityProvider, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of ingresses.
         * @param {string} [clusterId] 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdIngressesGet(clusterId?: string, page?: number, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20022>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdIngressesGet(clusterId, page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the ingress.
         * @param {string} [clusterId] 
         * @param {string} [ingressId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdIngressesIngressIdDelete(clusterId?: string, ingressId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdIngressesIngressIdDelete(clusterId, ingressId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the ingress.
         * @param {string} [clusterId] 
         * @param {string} [ingressId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdIngressesIngressIdGet(clusterId?: string, ingressId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ingress>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdIngressesIngressIdGet(clusterId, ingressId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the ingress.
         * @param {string} [clusterId] 
         * @param {string} [ingressId] 
         * @param {Ingress} [ingress] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdIngressesIngressIdPatch(clusterId?: string, ingressId?: string, ingress?: Ingress, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ingress>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdIngressesIngressIdPatch(clusterId, ingressId, ingress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates all ingresses
         * @param {string} [clusterId] 
         * @param {Array<Ingress>} [ingress] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdIngressesPatch(clusterId?: string, ingress?: Array<Ingress>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Ingress>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdIngressesPatch(clusterId, ingress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a new ingress to the cluster.
         * @param {string} [clusterId] 
         * @param {Ingress} [ingress] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdIngressesPost(clusterId?: string, ingress?: Ingress, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ingress>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdIngressesPost(clusterId, ingress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of reasons.
         * @param {string} [clusterId] 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsGet(clusterId?: string, page?: number, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20023>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsGet(clusterId, page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the reason.
         * @param {string} [clusterId] 
         * @param {string} [limitedSupportReasonId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsLimitedSupportReasonIdDelete(clusterId?: string, limitedSupportReasonId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsLimitedSupportReasonIdDelete(clusterId, limitedSupportReasonId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the reason.
         * @param {string} [clusterId] 
         * @param {string} [limitedSupportReasonId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsLimitedSupportReasonIdGet(clusterId?: string, limitedSupportReasonId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LimitedSupportReason>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsLimitedSupportReasonIdGet(clusterId, limitedSupportReasonId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a new reason to the cluster.
         * @param {string} [clusterId] 
         * @param {LimitedSupportReason} [limitedSupportReason] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsPost(clusterId?: string, limitedSupportReason?: LimitedSupportReason, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LimitedSupportReason>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsPost(clusterId, limitedSupportReason, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of log links.
         * @param {string} [clusterId] 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdLogsGet(clusterId?: string, page?: number, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20024>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdLogsGet(clusterId, page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the log.
         * @param {string} [clusterId] 
         * @param {number} [offset] Line offset to start logs from. if 0 retreive entire log. If offset &gt; #lines return an empty log.
         * @param {number} [tail] Returns the number of tail lines from the end of the log. If there are no line breaks or the number of lines &lt; tail return the entire log. Either \&#39;tail\&#39; or \&#39;offset\&#39; can be set. Not both. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdLogsInstallGet(clusterId?: string, offset?: number, tail?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Log>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdLogsInstallGet(clusterId, offset, tail, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the log.
         * @param {string} [clusterId] 
         * @param {number} [offset] Line offset to start logs from. if 0 retreive entire log. If offset &gt; #lines return an empty log.
         * @param {number} [tail] Returns the number of tail lines from the end of the log. If there are no line breaks or the number of lines &lt; tail return the entire log. Either \&#39;tail\&#39; or \&#39;offset\&#39; can be set. Not both. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdLogsUninstallGet(clusterId?: string, offset?: number, tail?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Log>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdLogsUninstallGet(clusterId, offset, tail, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of machine pools.
         * @param {string} [clusterId] 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdMachinePoolsGet(clusterId?: string, page?: number, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20025>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdMachinePoolsGet(clusterId, page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the machine pool.
         * @param {string} [clusterId] 
         * @param {string} [machinePoolId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdDelete(clusterId?: string, machinePoolId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdDelete(clusterId, machinePoolId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the machine pool.
         * @param {string} [clusterId] 
         * @param {string} [machinePoolId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdGet(clusterId?: string, machinePoolId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MachinePool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdGet(clusterId, machinePoolId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the machine pool.
         * @param {string} [clusterId] 
         * @param {string} [machinePoolId] 
         * @param {MachinePool} [machinePool] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdPatch(clusterId?: string, machinePoolId?: string, machinePool?: MachinePool, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MachinePool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdPatch(clusterId, machinePoolId, machinePool, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a new machine pool to the cluster.
         * @param {string} [clusterId] 
         * @param {MachinePool} [machinePool] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdMachinePoolsPost(clusterId?: string, machinePool?: MachinePool, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MachinePool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdMachinePoolsPost(clusterId, machinePool, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [clusterId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdMetricQueriesAlertsGet(clusterId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlertsInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdMetricQueriesAlertsGet(clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [clusterId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdMetricQueriesClusterOperatorsGet(clusterId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterOperatorsInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdMetricQueriesClusterOperatorsGet(clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the metrics.
         * @param {string} [clusterId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdMetricQueriesCpuTotalByNodeRolesOsGet(clusterId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CPUTotalsNodeRoleOSMetricNode>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdMetricQueriesCpuTotalByNodeRolesOsGet(clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [clusterId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdMetricQueriesNodesGet(clusterId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NodesInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdMetricQueriesNodesGet(clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the metrics.
         * @param {string} [clusterId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdMetricQueriesSocketTotalByNodeRolesOsGet(clusterId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SocketTotalsNodeRoleOSMetricNode>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdMetricQueriesSocketTotalByNodeRolesOsGet(clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the cluster.
         * @param {string} [clusterId] 
         * @param {Cluster} [cluster] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdPatch(clusterId?: string, cluster?: Cluster, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cluster>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdPatch(clusterId, cluster, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the product.
         * @param {string} [clusterId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdProductGet(clusterId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdProductGet(clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the provision shard.
         * @param {string} [clusterId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdProvisionShardGet(clusterId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvisionShard>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdProvisionShardGet(clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a list of resources for a cluster in error state
         * @param {string} [clusterId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdResourcesGet(clusterId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterResources>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdResourcesGet(clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves currently available cluster resources
         * @param {string} [clusterId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdResourcesLiveGet(clusterId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterResources>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdResourcesLiveGet(clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Resumes from Hibernation.
         * @param {string} [clusterId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdResumePost(clusterId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdResumePost(clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [clusterId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdStatusGet(clusterId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdStatusGet(clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of operator roles.
         * @param {string} [clusterId] 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdStsOperatorRolesGet(clusterId?: string, page?: number, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20026>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdStsOperatorRolesGet(clusterId, page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the operator role.
         * @param {string} [clusterId] 
         * @param {string} [operatorIamRoleId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdStsOperatorRolesOperatorIamRoleIdDelete(clusterId?: string, operatorIamRoleId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdStsOperatorRolesOperatorIamRoleIdDelete(clusterId, operatorIamRoleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a new operator role to the cluster.
         * @param {string} [clusterId] 
         * @param {OperatorIAMRole} [operatorIAMRole] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdStsOperatorRolesPost(clusterId?: string, operatorIAMRole?: OperatorIAMRole, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OperatorIAMRole>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdStsOperatorRolesPost(clusterId, operatorIAMRole, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of upgrade policies.
         * @param {string} [clusterId] 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdUpgradePoliciesGet(clusterId?: string, page?: number, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20027>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdUpgradePoliciesGet(clusterId, page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a new upgrade policy to the cluster.
         * @param {string} [clusterId] 
         * @param {UpgradePolicy} [upgradePolicy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdUpgradePoliciesPost(clusterId?: string, upgradePolicy?: UpgradePolicy, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpgradePolicy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdUpgradePoliciesPost(clusterId, upgradePolicy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the upgrade policy.
         * @param {string} [clusterId] 
         * @param {string} [upgradePolicyId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdDelete(clusterId?: string, upgradePolicyId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdDelete(clusterId, upgradePolicyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the upgrade policy.
         * @param {string} [clusterId] 
         * @param {string} [upgradePolicyId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdGet(clusterId?: string, upgradePolicyId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpgradePolicy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdGet(clusterId, upgradePolicyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the upgrade policy.
         * @param {string} [clusterId] 
         * @param {string} [upgradePolicyId] 
         * @param {UpgradePolicy} [upgradePolicy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdPatch(clusterId?: string, upgradePolicyId?: string, upgradePolicy?: UpgradePolicy, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpgradePolicy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdPatch(clusterId, upgradePolicyId, upgradePolicy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the upgrade policy state.
         * @param {string} [clusterId] 
         * @param {string} [upgradePolicyId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdStateGet(clusterId?: string, upgradePolicyId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpgradePolicyState>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdStateGet(clusterId, upgradePolicyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the upgrade policy state.
         * @param {string} [clusterId] 
         * @param {string} [upgradePolicyId] 
         * @param {UpgradePolicyState} [upgradePolicyState] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdStatePatch(clusterId?: string, upgradePolicyId?: string, upgradePolicyState?: UpgradePolicyState, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpgradePolicyState>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdStatePatch(clusterId, upgradePolicyId, upgradePolicyState, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of clusters.
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the cluster instead of the names of the columns of a table. For example, in order to sort the clusters descending by region identifier the value should be:  &#x60;&#x60;&#x60;sql region.id desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the cluster instead of the names of the columns of a table. For example, in order to retrieve all the clusters with a name starting with &#x60;my&#x60; in the &#x60;us-east-1&#x60; region the value should be:  &#x60;&#x60;&#x60;sql name like \&#39;my%\&#39; and region.id &#x3D; \&#39;us-east-1\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the clusters that the user has permission to see will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersGet(order?: string, page?: number, search?: string, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20011>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersGet(order, page, search, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Provision a new cluster and add it to the collection of clusters.  See the `register_cluster` method for adding an existing cluster.
         * @param {Cluster} [cluster] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersPost(cluster?: Cluster, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cluster>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersPost(cluster, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the environment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1EnvironmentGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Environment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1EnvironmentGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the environment.  Attributes that can be updated are:  - `last_upgrade_available_check` - `last_limited_support_check`
         * @param {Environment} [environment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1EnvironmentPatch(environment?: Environment, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Environment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1EnvironmentPatch(environment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a new event to be tracked. When sending a new event request, it gets tracked in Prometheus, Pendo, CloudWatch, or whichever analytics client is configured as part of clusters service. This allows for reporting on events that happen outside of a regular API request, but are found to be useful for understanding customer needs and possible blockers.
         * @param {Event} [event] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1EventsPost(event?: Event, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1EventsPost(event, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the cluster flavour.
         * @param {string} [flavourId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1FlavoursFlavourIdGet(flavourId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Flavour>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1FlavoursFlavourIdGet(flavourId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the flavour.  Attributes that can be updated are:  - `aws.infra_volume` - `aws.infra_instance_type` - `gcp.infra_instance_type`
         * @param {string} [flavourId] 
         * @param {Flavour} [flavour] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1FlavoursFlavourIdPatch(flavourId?: string, flavour?: Flavour, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Flavour>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1FlavoursFlavourIdPatch(flavourId, flavour, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the flavour instead of the names of the columns of a table. For example, in order to sort the flavours descending by name the value should be:  &#x60;&#x60;&#x60;sql name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the flavour instead of the names of the columns of a table. For example, in order to retrieve all the flavours with a name starting with &#x60;my&#x60;the value should be:  &#x60;&#x60;&#x60;sql name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the flavours that the user has permission to see will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1FlavoursGet(order?: string, page?: number, search?: string, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20028>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1FlavoursGet(order, page, search, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a new cluster flavour.
         * @param {Flavour} [flavour] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1FlavoursPost(flavour?: Flavour, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Flavour>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1FlavoursPost(flavour, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of encryption keys. IMPORTANT: This collection doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of available regions of the provider.
         * @param {number} [page] Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;.
         * @param {number} [size] Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of regions of the provider.
         * @param {CloudProviderData} [cloudProviderData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1GcpInquiriesEncryptionKeysPost(page?: number, size?: number, cloudProviderData?: CloudProviderData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20029>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1GcpInquiriesEncryptionKeysPost(page, size, cloudProviderData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of available key rings of the cloud provider. IMPORTANT: This collection doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of available regions of the provider.
         * @param {number} [page] Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;.
         * @param {number} [size] Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of key rings of the provider.
         * @param {CloudProviderData} [cloudProviderData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1GcpInquiriesKeyRingsPost(page?: number, size?: number, cloudProviderData?: CloudProviderData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20030>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1GcpInquiriesKeyRingsPost(page, size, cloudProviderData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of available regions of the cloud provider. IMPORTANT: This list doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of available regions of the provider.
         * @param {number} [page] Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;.
         * @param {number} [size] Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of regions of the provider.
         * @param {CloudProviderData} [cloudProviderData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1GcpInquiriesRegionsPost(page?: number, size?: number, cloudProviderData?: CloudProviderData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1GcpInquiriesRegionsPost(page, size, cloudProviderData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of available vpcs of the cloud provider for specific region. IMPORTANT: This collection doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of available vpcs of the provider.
         * @param {number} [page] Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;.
         * @param {number} [size] Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of vpcs of the provider.
         * @param {CloudProviderData} [cloudProviderData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1GcpInquiriesVpcsPost(page?: number, size?: number, cloudProviderData?: CloudProviderData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2007>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1GcpInquiriesVpcsPost(page, size, cloudProviderData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the version metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1Get(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Metadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1Get(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of templates.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1LimitedSupportReasonTemplatesGet(page?: number, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20031>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1LimitedSupportReasonTemplatesGet(page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the template.
         * @param {string} [limitedSupportReasonTemplateId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1LimitedSupportReasonTemplatesLimitedSupportReasonTemplateIdGet(limitedSupportReasonTemplateId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LimitedSupportReasonTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1LimitedSupportReasonTemplatesLimitedSupportReasonTemplateIdGet(limitedSupportReasonTemplateId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of machine types.
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the machine type instead of the names of the columns of a table. For example, in order to sort the machine types descending by name identifier the value should be:  &#x60;&#x60;&#x60;sql name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the machine type instead of the names of the columns of a table. For example, in order to retrieve all the machine types with a name starting with &#x60;A&#x60; the value should be:  &#x60;&#x60;&#x60;sql name like \&#39;A%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the machine types that the user has permission to see will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1MachineTypesGet(order?: string, page?: number, search?: string, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20032>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1MachineTypesGet(order, page, search, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of products.
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the product instead of the names of the columns of a table. For example, in order to sort the products descending by name the value should be:  &#x60;&#x60;&#x60;sql name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the product instead of the names of the columns of a table. For example, in order to retrieve all the products with a name starting with &#x60;my&#x60; the value should be:  &#x60;&#x60;&#x60;sql name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the products that the user has permission to see will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ProductsGet(order?: string, page?: number, search?: string, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20033>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ProductsGet(order, page, search, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the product.
         * @param {string} [productId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ProductsProductIdGet(productId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ProductsProductIdGet(productId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ProvisionShardsGet(page?: number, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20034>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ProvisionShardsGet(page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the provision shard.
         * @param {string} [provisionShardId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ProvisionShardsProvisionShardIdGet(provisionShardId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvisionShard>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ProvisionShardsProvisionShardIdGet(provisionShardId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a list of version gates.
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of an SQL statement, but using the names of the attributes of the version gate instead of the names of the columns of a table. For example, in order to sort the version gates descending by identifier the value should be:  &#x60;&#x60;&#x60;sql id desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the version gate instead of the names of the columns of a table.  If the parameter isn\&#39;t provided, or if the value is empty, then all the version gates that the user has permission to see will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.  Default value is &#x60;100&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1VersionGatesGet(order?: string, page?: number, search?: string, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20035>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1VersionGatesGet(order, page, search, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a new version gate
         * @param {VersionGate} [versionGate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1VersionGatesPost(versionGate?: VersionGate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VersionGate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1VersionGatesPost(versionGate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the version gate.
         * @param {string} [versionGateId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1VersionGatesVersionGateIdDelete(versionGateId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1VersionGatesVersionGateIdDelete(versionGateId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the version gate.
         * @param {string} [versionGateId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1VersionGatesVersionGateIdGet(versionGateId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VersionGate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1VersionGatesVersionGateIdGet(versionGateId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a list of versions.
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the version instead of the names of the columns of a table. For example, in order to sort the versions descending by identifier the value should be:  &#x60;&#x60;&#x60;sql id desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the version instead of the names of the columns of a table. For example, in order to retrieve all the versions that are enabled:  &#x60;&#x60;&#x60;sql enabled &#x3D; \&#39;t\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the versions that the user has permission to see will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.  Default value is &#x60;100&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1VersionsGet(order?: string, page?: number, search?: string, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20036>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1VersionsGet(order, page, search, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the version.
         * @param {string} [versionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1VersionsVersionIdGet(versionId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Version>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1VersionsVersionIdGet(versionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * Deletes the add-on.
         * @param {string} [addonId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AddonsAddonIdDelete(addonId?: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiClustersMgmtV1AddonsAddonIdDelete(addonId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the add-on.
         * @param {string} [addonId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AddonsAddonIdGet(addonId?: string, options?: any): AxiosPromise<AddOn> {
            return localVarFp.apiClustersMgmtV1AddonsAddonIdGet(addonId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the add-on.
         * @param {string} [addonId] 
         * @param {AddOn} [addOn] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AddonsAddonIdPatch(addonId?: string, addOn?: AddOn, options?: any): AxiosPromise<AddOn> {
            return localVarFp.apiClustersMgmtV1AddonsAddonIdPatch(addonId, addOn, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of add-on versions.
         * @param {string} [addonId] 
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the add-on instead of the names of the columns of a table. For example, in order to sort the add-on versions descending by id the value should be:  &#x60;&#x60;&#x60;sql id desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the add-on version instead of the names of the columns of a table. For example, in order to retrieve all the add-on versions with an id starting with &#x60;0.1&#x60; the value should be:  &#x60;&#x60;&#x60;sql id like \&#39;0.1.%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the add-on versions that the user has permission to see will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AddonsAddonIdVersionsGet(addonId?: string, order?: string, page?: number, search?: string, size?: number, options?: any): AxiosPromise<InlineResponse2001> {
            return localVarFp.apiClustersMgmtV1AddonsAddonIdVersionsGet(addonId, order, page, search, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new add-on version and add it to the collection of add-ons.
         * @param {string} [addonId] 
         * @param {AddOnVersion} [addOnVersion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AddonsAddonIdVersionsPost(addonId?: string, addOnVersion?: AddOnVersion, options?: any): AxiosPromise<AddOnVersion> {
            return localVarFp.apiClustersMgmtV1AddonsAddonIdVersionsPost(addonId, addOnVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the add-on version.
         * @param {string} [addonId] 
         * @param {string} [versionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AddonsAddonIdVersionsVersionIdDelete(addonId?: string, versionId?: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiClustersMgmtV1AddonsAddonIdVersionsVersionIdDelete(addonId, versionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the add-on version.
         * @param {string} [addonId] 
         * @param {string} [versionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AddonsAddonIdVersionsVersionIdGet(addonId?: string, versionId?: string, options?: any): AxiosPromise<AddOnVersion> {
            return localVarFp.apiClustersMgmtV1AddonsAddonIdVersionsVersionIdGet(addonId, versionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the add-on version.
         * @param {string} [addonId] 
         * @param {string} [versionId] 
         * @param {AddOnVersion} [addOnVersion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AddonsAddonIdVersionsVersionIdPatch(addonId?: string, versionId?: string, addOnVersion?: AddOnVersion, options?: any): AxiosPromise<AddOnVersion> {
            return localVarFp.apiClustersMgmtV1AddonsAddonIdVersionsVersionIdPatch(addonId, versionId, addOnVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of add-ons.
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the add-on instead of the names of the columns of a table. For example, in order to sort the add-ons descending by name the value should be:  &#x60;&#x60;&#x60;sql name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the add-on instead of the names of the columns of a table. For example, in order to retrieve all the add-ons with a name starting with &#x60;my&#x60; the value should be:  &#x60;&#x60;&#x60;sql name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the add-ons that the user has permission to see will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AddonsGet(order?: string, page?: number, search?: string, size?: number, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.apiClustersMgmtV1AddonsGet(order, page, search, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new add-on and add it to the collection of add-ons.
         * @param {AddOn} [addOn] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AddonsPost(addOn?: AddOn, options?: any): AxiosPromise<AddOn> {
            return localVarFp.apiClustersMgmtV1AddonsPost(addOn, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the aws infrastructure access role.
         * @param {string} [awsInfrastructureAccessRoleId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AwsInfrastructureAccessRolesAwsInfrastructureAccessRoleIdGet(awsInfrastructureAccessRoleId?: string, options?: any): AxiosPromise<AWSInfrastructureAccessRole> {
            return localVarFp.apiClustersMgmtV1AwsInfrastructureAccessRolesAwsInfrastructureAccessRoleIdGet(awsInfrastructureAccessRoleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the role instead of the names of the columns of a table. For example, in order to sort the roles descending by dislay_name the value should be:  &#x60;&#x60;&#x60;sql display_name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the role instead of the names of the columns of a table. For example, in order to retrieve all the role with a name starting with &#x60;my&#x60;the value should be:  &#x60;&#x60;&#x60;sql display_name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the roles that the user has permission to see will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AwsInfrastructureAccessRolesGet(order?: string, page?: number, search?: string, size?: number, options?: any): AxiosPromise<InlineResponse2002> {
            return localVarFp.apiClustersMgmtV1AwsInfrastructureAccessRolesGet(order, page, search, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of machine types in the provided region.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {CloudProviderData} [cloudProviderData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AwsInquiriesMachineTypesPost(page?: number, size?: number, cloudProviderData?: CloudProviderData, options?: any): AxiosPromise<InlineResponse2003> {
            return localVarFp.apiClustersMgmtV1AwsInquiriesMachineTypesPost(page, size, cloudProviderData, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of available regions of the cloud provider. IMPORTANT: This list doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of available regions of the provider.
         * @param {number} [page] Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;.
         * @param {number} [size] Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of regions of the provider.
         * @param {CloudProviderData} [cloudProviderData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AwsInquiriesRegionsPost(page?: number, size?: number, cloudProviderData?: CloudProviderData, options?: any): AxiosPromise<InlineResponse2004> {
            return localVarFp.apiClustersMgmtV1AwsInquiriesRegionsPost(page, size, cloudProviderData, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of policies.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AwsInquiriesStsCredentialRequestsGet(page?: number, size?: number, options?: any): AxiosPromise<InlineResponse2005> {
            return localVarFp.apiClustersMgmtV1AwsInquiriesStsCredentialRequestsGet(page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of policies.
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the awsstspolicies instead of the names of the columns of a table. For example, in order to sort the policies descending by operator type identifier the value should be:  &#x60;&#x60;&#x60;sql orderBy id desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the awsstspolicies instead of the names of the columns of a table. For example, in order to retrieve all the policies of type  &#x60;operatorrole&#x60; should be:  &#x60;&#x60;&#x60;sql policy_type like \&#39;OperatorRole%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the policies  will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AwsInquiriesStsPoliciesGet(order?: string, page?: number, search?: string, size?: number, options?: any): AxiosPromise<InlineResponse2006> {
            return localVarFp.apiClustersMgmtV1AwsInquiriesStsPoliciesGet(order, page, search, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of available vpcs of the cloud provider for specific region. IMPORTANT: This collection doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of available vpcs of the provider.
         * @param {number} [page] Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;.
         * @param {number} [size] Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of vpcs of the provider.
         * @param {CloudProviderData} [cloudProviderData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AwsInquiriesVpcsPost(page?: number, size?: number, cloudProviderData?: CloudProviderData, options?: any): AxiosPromise<InlineResponse2007> {
            return localVarFp.apiClustersMgmtV1AwsInquiriesVpcsPost(page, size, cloudProviderData, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of available regions of the cloud provider.  IMPORTANT: This collection doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of available regions of the provider.
         * @param {string} [cloudProviderId] 
         * @param {number} [page] Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;.
         * @param {number} [size] Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of regions of the provider.
         * @param {AWS} [aWS] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1CloudProvidersCloudProviderIdAvailableRegionsPost(cloudProviderId?: string, page?: number, size?: number, aWS?: AWS, options?: any): AxiosPromise<InlineResponse2009> {
            return localVarFp.apiClustersMgmtV1CloudProvidersCloudProviderIdAvailableRegionsPost(cloudProviderId, page, size, aWS, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the cloud provider.
         * @param {string} [cloudProviderId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1CloudProvidersCloudProviderIdGet(cloudProviderId?: string, options?: any): AxiosPromise<CloudProvider> {
            return localVarFp.apiClustersMgmtV1CloudProvidersCloudProviderIdGet(cloudProviderId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of regions of the cloud provider.  IMPORTANT: This collection doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of regions of the provider.
         * @param {string} [cloudProviderId] 
         * @param {number} [page] Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;.
         * @param {number} [size] Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of regions of the provider.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsGet(cloudProviderId?: string, page?: number, size?: number, options?: any): AxiosPromise<InlineResponse20010> {
            return localVarFp.apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsGet(cloudProviderId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the region.
         * @param {string} [cloudProviderId] 
         * @param {string} [regionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsRegionIdGet(cloudProviderId?: string, regionId?: string, options?: any): AxiosPromise<CloudRegion> {
            return localVarFp.apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsRegionIdGet(cloudProviderId, regionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of cloud providers.
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the cloud provider instead of the names of the columns of a table. For example, in order to sort the clusters descending by name identifier the value should be:  &#x60;&#x60;&#x60;sql name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the cloud provider instead of the names of the columns of a table. For example, in order to retrieve all the cloud providers with a name starting with &#x60;A&#x60; the value should be:  &#x60;&#x60;&#x60;sql name like \&#39;A%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the clusters that the user has permission to see will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1CloudProvidersGet(order?: string, page?: number, search?: string, size?: number, options?: any): AxiosPromise<InlineResponse2008> {
            return localVarFp.apiClustersMgmtV1CloudProvidersGet(order, page, search, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [clusterId] 
         * @param {string} [addonInquiryId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAddonInquiriesAddonInquiryIdGet(clusterId?: string, addonInquiryId?: string, options?: any): AxiosPromise<AddOn> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdAddonInquiriesAddonInquiryIdGet(clusterId, addonInquiryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [clusterId] 
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the add-on instead of the names of the columns of a table. For example, in order to sort the add-ons descending by name the value should be:  &#x60;&#x60;&#x60;sql name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the add-on instead of the names of the columns of a table. For example, in order to retrieve all the add-ons with a name starting with &#x60;my&#x60; the value should be:  &#x60;&#x60;&#x60;sql name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the add-ons that the user has permission to see will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAddonInquiriesGet(clusterId?: string, order?: string, page?: number, search?: string, size?: number, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdAddonInquiriesGet(clusterId, order, page, search, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an add-on installation and remove it from the collection of add-on installations on the cluster.
         * @param {string} [clusterId] 
         * @param {string} [addoninstallationId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdDelete(clusterId?: string, addoninstallationId?: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdDelete(clusterId, addoninstallationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the add-on installation.
         * @param {string} [clusterId] 
         * @param {string} [addoninstallationId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdGet(clusterId?: string, addoninstallationId?: string, options?: any): AxiosPromise<AddOnInstallation> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdGet(clusterId, addoninstallationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the add-on installation.
         * @param {string} [clusterId] 
         * @param {string} [addoninstallationId] 
         * @param {AddOnInstallation} [addOnInstallation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdPatch(clusterId?: string, addoninstallationId?: string, addOnInstallation?: AddOnInstallation, options?: any): AxiosPromise<AddOnInstallation> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdPatch(clusterId, addoninstallationId, addOnInstallation, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of add-on installations.
         * @param {string} [clusterId] 
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the add-on installation instead of the names of the columns of a table. For example, in order to sort the add-on installations descending by name the value should be:  &#x60;&#x60;&#x60;sql name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the add-on installation instead of the names of the columns of a table. For example, in order to retrieve all the add-on installations with a name starting with &#x60;my&#x60; the value should be:  &#x60;&#x60;&#x60;sql name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the add-on installations that the user has permission to see will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAddonsGet(clusterId?: string, order?: string, page?: number, search?: string, size?: number, options?: any): AxiosPromise<InlineResponse20012> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdAddonsGet(clusterId, order, page, search, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new add-on installation and add it to the collection of add-on installations on the cluster.
         * @param {string} [clusterId] 
         * @param {AddOnInstallation} [addOnInstallation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAddonsPost(clusterId?: string, addOnInstallation?: AddOnInstallation, options?: any): AxiosPromise<AddOnInstallation> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdAddonsPost(clusterId, addOnInstallation, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the AWS infrastructure access role grant.
         * @param {string} [clusterId] 
         * @param {string} [awsInfrastructureAccessRoleGrantId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsAwsInfrastructureAccessRoleGrantIdDelete(clusterId?: string, awsInfrastructureAccessRoleGrantId?: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsAwsInfrastructureAccessRoleGrantIdDelete(clusterId, awsInfrastructureAccessRoleGrantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the AWS infrastructure access role grant.
         * @param {string} [clusterId] 
         * @param {string} [awsInfrastructureAccessRoleGrantId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsAwsInfrastructureAccessRoleGrantIdGet(clusterId?: string, awsInfrastructureAccessRoleGrantId?: string, options?: any): AxiosPromise<AWSInfrastructureAccessRoleGrant> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsAwsInfrastructureAccessRoleGrantIdGet(clusterId, awsInfrastructureAccessRoleGrantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of AWS infrastructure access role grants.
         * @param {string} [clusterId] 
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the AWS infrastructure access role grant instead of the names of the columns of a table. For example, in order to sort the AWS infrastructure access role grants descending by user ARN the value should be:  &#x60;&#x60;&#x60;sql user_arn desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the AWS infrastructure access role grant instead of the names of the columns of a table. For example, in order to retrieve all the AWS infrastructure access role grants with a user ARN starting with &#x60;user&#x60; the value should be:  &#x60;&#x60;&#x60;sql user_arn like \&#39;%user\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the AWS infrastructure access role grants that the user has permission to see will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsGet(clusterId?: string, order?: string, page?: number, search?: string, size?: number, options?: any): AxiosPromise<InlineResponse20013> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsGet(clusterId, order, page, search, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new AWS infrastructure access role grant and add it to the collection of AWS infrastructure access role grants on the cluster.
         * @param {string} [clusterId] 
         * @param {AWSInfrastructureAccessRoleGrant} [aWSInfrastructureAccessRoleGrant] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsPost(clusterId?: string, aWSInfrastructureAccessRoleGrant?: AWSInfrastructureAccessRoleGrant, options?: any): AxiosPromise<AWSInfrastructureAccessRoleGrant> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsPost(clusterId, aWSInfrastructureAccessRoleGrant, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the clusterdeployment.
         * @param {string} [clusterId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdClusterdeploymentDelete(clusterId?: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdClusterdeploymentDelete(clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the credentials of a cluster.
         * @param {string} [clusterId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdCredentialsGet(clusterId?: string, options?: any): AxiosPromise<ClusterCredentials> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdCredentialsGet(clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the cluster.
         * @param {string} [clusterId] 
         * @param {boolean} [deprovision] If false it will only delete from OCM but not the actual cluster resources. false is only allowed for OCP clusters. true by default.
         * @param {boolean} [dryRun] Dry run flag is used to check if the operation can be completed, but won\&#39;t delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdDelete(clusterId?: string, deprovision?: boolean, dryRun?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdDelete(clusterId, deprovision, dryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the external configuration.
         * @param {string} [clusterId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationGet(clusterId?: string, options?: any): AxiosPromise<ExternalConfiguration> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdExternalConfigurationGet(clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of labels.
         * @param {string} [clusterId] 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsGet(clusterId?: string, page?: number, size?: number, options?: any): AxiosPromise<InlineResponse20014> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsGet(clusterId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the label.
         * @param {string} [clusterId] 
         * @param {string} [labelId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdDelete(clusterId?: string, labelId?: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdDelete(clusterId, labelId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the label.
         * @param {string} [clusterId] 
         * @param {string} [labelId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdGet(clusterId?: string, labelId?: string, options?: any): AxiosPromise<Label> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdGet(clusterId, labelId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the label.
         * @param {string} [clusterId] 
         * @param {string} [labelId] 
         * @param {Label} [label] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdPatch(clusterId?: string, labelId?: string, label?: Label, options?: any): AxiosPromise<Label> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdPatch(clusterId, labelId, label, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a new label to the cluster.
         * @param {string} [clusterId] 
         * @param {Label} [label] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsPost(clusterId?: string, label?: Label, options?: any): AxiosPromise<Label> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsPost(clusterId, label, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of syncsets.
         * @param {string} [clusterId] 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsGet(clusterId?: string, page?: number, size?: number, options?: any): AxiosPromise<InlineResponse20015> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsGet(clusterId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a new syncset to the cluster.
         * @param {string} [clusterId] 
         * @param {Syncset} [syncset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsPost(clusterId?: string, syncset?: Syncset, options?: any): AxiosPromise<Syncset> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsPost(clusterId, syncset, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the syncset.
         * @param {string} [clusterId] 
         * @param {string} [syncsetId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdDelete(clusterId?: string, syncsetId?: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdDelete(clusterId, syncsetId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the syncset.
         * @param {string} [clusterId] 
         * @param {string} [syncsetId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdGet(clusterId?: string, syncsetId?: string, options?: any): AxiosPromise<Syncset> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdGet(clusterId, syncsetId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the syncset.
         * @param {string} [clusterId] 
         * @param {string} [syncsetId] 
         * @param {Syncset} [syncset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdPatch(clusterId?: string, syncsetId?: string, syncset?: Syncset, options?: any): AxiosPromise<Syncset> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdPatch(clusterId, syncsetId, syncset, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of reasons.
         * @param {string} [clusterId] 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdGateAgreementsGet(clusterId?: string, page?: number, size?: number, options?: any): AxiosPromise<InlineResponse20016> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdGateAgreementsGet(clusterId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a new agreed version gate to the cluster.
         * @param {string} [clusterId] 
         * @param {VersionGateAgreement} [versionGateAgreement] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdGateAgreementsPost(clusterId?: string, versionGateAgreement?: VersionGateAgreement, options?: any): AxiosPromise<VersionGateAgreement> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdGateAgreementsPost(clusterId, versionGateAgreement, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the version gate agreement.
         * @param {string} [clusterId] 
         * @param {string} [versionGateAgreementId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdGateAgreementsVersionGateAgreementIdDelete(clusterId?: string, versionGateAgreementId?: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdGateAgreementsVersionGateAgreementIdDelete(clusterId, versionGateAgreementId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the version gate agreement.
         * @param {string} [clusterId] 
         * @param {string} [versionGateAgreementId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdGateAgreementsVersionGateAgreementIdGet(clusterId?: string, versionGateAgreementId?: string, options?: any): AxiosPromise<VersionGateAgreement> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdGateAgreementsVersionGateAgreementIdGet(clusterId, versionGateAgreementId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the cluster.
         * @param {string} [clusterId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdGet(clusterId?: string, options?: any): AxiosPromise<Cluster> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdGet(clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of groups.
         * @param {string} [clusterId] 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdGroupsGet(clusterId?: string, page?: number, size?: number, options?: any): AxiosPromise<InlineResponse20017> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdGroupsGet(clusterId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the group.
         * @param {string} [clusterId] 
         * @param {string} [groupId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdGroupsGroupIdGet(clusterId?: string, groupId?: string, options?: any): AxiosPromise<Group> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdGroupsGroupIdGet(clusterId, groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of users.
         * @param {string} [clusterId] 
         * @param {string} [groupId] 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersGet(clusterId?: string, groupId?: string, page?: number, size?: number, options?: any): AxiosPromise<InlineResponse20018> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersGet(clusterId, groupId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a new user to the group.
         * @param {string} [clusterId] 
         * @param {string} [groupId] 
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersPost(clusterId?: string, groupId?: string, user?: User, options?: any): AxiosPromise<User> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersPost(clusterId, groupId, user, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the user.
         * @param {string} [clusterId] 
         * @param {string} [groupId] 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdDelete(clusterId?: string, groupId?: string, userId?: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdDelete(clusterId, groupId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the user.
         * @param {string} [clusterId] 
         * @param {string} [groupId] 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdGet(clusterId?: string, groupId?: string, userId?: string, options?: any): AxiosPromise<User> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdGet(clusterId, groupId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Initiates cluster hibernation. While hibernating a cluster will not consume any cloud provider infrastructure but will be counted for quota.
         * @param {string} [clusterId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdHibernatePost(clusterId?: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdHibernatePost(clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of identity providers.
         * @param {string} [clusterId] 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIdentityProvidersGet(clusterId?: string, page?: number, size?: number, options?: any): AxiosPromise<InlineResponse20019> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdIdentityProvidersGet(clusterId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the identity provider.
         * @param {string} [clusterId] 
         * @param {string} [identityProviderId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdDelete(clusterId?: string, identityProviderId?: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdDelete(clusterId, identityProviderId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the identity provider.
         * @param {string} [clusterId] 
         * @param {string} [identityProviderId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdGet(clusterId?: string, identityProviderId?: string, options?: any): AxiosPromise<IdentityProvider> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdGet(clusterId, identityProviderId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of _HTPasswd_ IDP users.
         * @param {string} [clusterId] 
         * @param {string} [identityProviderId] 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersGet(clusterId?: string, identityProviderId?: string, page?: number, size?: number, options?: any): AxiosPromise<InlineResponse20020> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersGet(clusterId, identityProviderId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the user.
         * @param {string} [clusterId] 
         * @param {string} [identityProviderId] 
         * @param {string} [htpasswdUserId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdDelete(clusterId?: string, identityProviderId?: string, htpasswdUserId?: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdDelete(clusterId, identityProviderId, htpasswdUserId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the user.
         * @param {string} [clusterId] 
         * @param {string} [identityProviderId] 
         * @param {string} [htpasswdUserId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdGet(clusterId?: string, identityProviderId?: string, htpasswdUserId?: string, options?: any): AxiosPromise<HTPasswdUser> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdGet(clusterId, identityProviderId, htpasswdUserId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the user\'s password. The username is not editable
         * @param {string} [clusterId] 
         * @param {string} [identityProviderId] 
         * @param {string} [htpasswdUserId] 
         * @param {HTPasswdUser} [hTPasswdUser] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdPatch(clusterId?: string, identityProviderId?: string, htpasswdUserId?: string, hTPasswdUser?: HTPasswdUser, options?: any): AxiosPromise<HTPasswdUser> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdPatch(clusterId, identityProviderId, htpasswdUserId, hTPasswdUser, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds multiple new users to the _HTPasswd_ file.
         * @param {string} [clusterId] 
         * @param {string} [identityProviderId] 
         * @param {InlineObject} [inlineObject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersImportPost(clusterId?: string, identityProviderId?: string, inlineObject?: InlineObject, options?: any): AxiosPromise<InlineResponse20021> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersImportPost(clusterId, identityProviderId, inlineObject, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a new user to the _HTPasswd_ file.
         * @param {string} [clusterId] 
         * @param {string} [identityProviderId] 
         * @param {HTPasswdUser} [hTPasswdUser] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersPost(clusterId?: string, identityProviderId?: string, hTPasswdUser?: HTPasswdUser, options?: any): AxiosPromise<HTPasswdUser> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersPost(clusterId, identityProviderId, hTPasswdUser, options).then((request) => request(axios, basePath));
        },
        /**
         * Update identity provider in the cluster.
         * @param {string} [clusterId] 
         * @param {string} [identityProviderId] 
         * @param {IdentityProvider} [identityProvider] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdPatch(clusterId?: string, identityProviderId?: string, identityProvider?: IdentityProvider, options?: any): AxiosPromise<IdentityProvider> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdPatch(clusterId, identityProviderId, identityProvider, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a new identity provider to the cluster.
         * @param {string} [clusterId] 
         * @param {IdentityProvider} [identityProvider] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIdentityProvidersPost(clusterId?: string, identityProvider?: IdentityProvider, options?: any): AxiosPromise<IdentityProvider> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdIdentityProvidersPost(clusterId, identityProvider, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of ingresses.
         * @param {string} [clusterId] 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIngressesGet(clusterId?: string, page?: number, size?: number, options?: any): AxiosPromise<InlineResponse20022> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdIngressesGet(clusterId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the ingress.
         * @param {string} [clusterId] 
         * @param {string} [ingressId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIngressesIngressIdDelete(clusterId?: string, ingressId?: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdIngressesIngressIdDelete(clusterId, ingressId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the ingress.
         * @param {string} [clusterId] 
         * @param {string} [ingressId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIngressesIngressIdGet(clusterId?: string, ingressId?: string, options?: any): AxiosPromise<Ingress> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdIngressesIngressIdGet(clusterId, ingressId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the ingress.
         * @param {string} [clusterId] 
         * @param {string} [ingressId] 
         * @param {Ingress} [ingress] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIngressesIngressIdPatch(clusterId?: string, ingressId?: string, ingress?: Ingress, options?: any): AxiosPromise<Ingress> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdIngressesIngressIdPatch(clusterId, ingressId, ingress, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates all ingresses
         * @param {string} [clusterId] 
         * @param {Array<Ingress>} [ingress] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIngressesPatch(clusterId?: string, ingress?: Array<Ingress>, options?: any): AxiosPromise<Array<Ingress>> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdIngressesPatch(clusterId, ingress, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a new ingress to the cluster.
         * @param {string} [clusterId] 
         * @param {Ingress} [ingress] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIngressesPost(clusterId?: string, ingress?: Ingress, options?: any): AxiosPromise<Ingress> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdIngressesPost(clusterId, ingress, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of reasons.
         * @param {string} [clusterId] 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsGet(clusterId?: string, page?: number, size?: number, options?: any): AxiosPromise<InlineResponse20023> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsGet(clusterId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the reason.
         * @param {string} [clusterId] 
         * @param {string} [limitedSupportReasonId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsLimitedSupportReasonIdDelete(clusterId?: string, limitedSupportReasonId?: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsLimitedSupportReasonIdDelete(clusterId, limitedSupportReasonId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the reason.
         * @param {string} [clusterId] 
         * @param {string} [limitedSupportReasonId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsLimitedSupportReasonIdGet(clusterId?: string, limitedSupportReasonId?: string, options?: any): AxiosPromise<LimitedSupportReason> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsLimitedSupportReasonIdGet(clusterId, limitedSupportReasonId, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a new reason to the cluster.
         * @param {string} [clusterId] 
         * @param {LimitedSupportReason} [limitedSupportReason] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsPost(clusterId?: string, limitedSupportReason?: LimitedSupportReason, options?: any): AxiosPromise<LimitedSupportReason> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsPost(clusterId, limitedSupportReason, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of log links.
         * @param {string} [clusterId] 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdLogsGet(clusterId?: string, page?: number, size?: number, options?: any): AxiosPromise<InlineResponse20024> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdLogsGet(clusterId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the log.
         * @param {string} [clusterId] 
         * @param {number} [offset] Line offset to start logs from. if 0 retreive entire log. If offset &gt; #lines return an empty log.
         * @param {number} [tail] Returns the number of tail lines from the end of the log. If there are no line breaks or the number of lines &lt; tail return the entire log. Either \&#39;tail\&#39; or \&#39;offset\&#39; can be set. Not both. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdLogsInstallGet(clusterId?: string, offset?: number, tail?: number, options?: any): AxiosPromise<Log> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdLogsInstallGet(clusterId, offset, tail, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the log.
         * @param {string} [clusterId] 
         * @param {number} [offset] Line offset to start logs from. if 0 retreive entire log. If offset &gt; #lines return an empty log.
         * @param {number} [tail] Returns the number of tail lines from the end of the log. If there are no line breaks or the number of lines &lt; tail return the entire log. Either \&#39;tail\&#39; or \&#39;offset\&#39; can be set. Not both. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdLogsUninstallGet(clusterId?: string, offset?: number, tail?: number, options?: any): AxiosPromise<Log> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdLogsUninstallGet(clusterId, offset, tail, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of machine pools.
         * @param {string} [clusterId] 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdMachinePoolsGet(clusterId?: string, page?: number, size?: number, options?: any): AxiosPromise<InlineResponse20025> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdMachinePoolsGet(clusterId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the machine pool.
         * @param {string} [clusterId] 
         * @param {string} [machinePoolId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdDelete(clusterId?: string, machinePoolId?: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdDelete(clusterId, machinePoolId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the machine pool.
         * @param {string} [clusterId] 
         * @param {string} [machinePoolId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdGet(clusterId?: string, machinePoolId?: string, options?: any): AxiosPromise<MachinePool> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdGet(clusterId, machinePoolId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the machine pool.
         * @param {string} [clusterId] 
         * @param {string} [machinePoolId] 
         * @param {MachinePool} [machinePool] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdPatch(clusterId?: string, machinePoolId?: string, machinePool?: MachinePool, options?: any): AxiosPromise<MachinePool> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdPatch(clusterId, machinePoolId, machinePool, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a new machine pool to the cluster.
         * @param {string} [clusterId] 
         * @param {MachinePool} [machinePool] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdMachinePoolsPost(clusterId?: string, machinePool?: MachinePool, options?: any): AxiosPromise<MachinePool> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdMachinePoolsPost(clusterId, machinePool, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [clusterId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdMetricQueriesAlertsGet(clusterId?: string, options?: any): AxiosPromise<AlertsInfo> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdMetricQueriesAlertsGet(clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [clusterId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdMetricQueriesClusterOperatorsGet(clusterId?: string, options?: any): AxiosPromise<ClusterOperatorsInfo> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdMetricQueriesClusterOperatorsGet(clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the metrics.
         * @param {string} [clusterId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdMetricQueriesCpuTotalByNodeRolesOsGet(clusterId?: string, options?: any): AxiosPromise<CPUTotalsNodeRoleOSMetricNode> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdMetricQueriesCpuTotalByNodeRolesOsGet(clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [clusterId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdMetricQueriesNodesGet(clusterId?: string, options?: any): AxiosPromise<NodesInfo> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdMetricQueriesNodesGet(clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the metrics.
         * @param {string} [clusterId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdMetricQueriesSocketTotalByNodeRolesOsGet(clusterId?: string, options?: any): AxiosPromise<SocketTotalsNodeRoleOSMetricNode> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdMetricQueriesSocketTotalByNodeRolesOsGet(clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the cluster.
         * @param {string} [clusterId] 
         * @param {Cluster} [cluster] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdPatch(clusterId?: string, cluster?: Cluster, options?: any): AxiosPromise<Cluster> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdPatch(clusterId, cluster, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the product.
         * @param {string} [clusterId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdProductGet(clusterId?: string, options?: any): AxiosPromise<Product> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdProductGet(clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the provision shard.
         * @param {string} [clusterId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdProvisionShardGet(clusterId?: string, options?: any): AxiosPromise<ProvisionShard> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdProvisionShardGet(clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of resources for a cluster in error state
         * @param {string} [clusterId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdResourcesGet(clusterId?: string, options?: any): AxiosPromise<ClusterResources> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdResourcesGet(clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves currently available cluster resources
         * @param {string} [clusterId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdResourcesLiveGet(clusterId?: string, options?: any): AxiosPromise<ClusterResources> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdResourcesLiveGet(clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Resumes from Hibernation.
         * @param {string} [clusterId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdResumePost(clusterId?: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdResumePost(clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [clusterId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdStatusGet(clusterId?: string, options?: any): AxiosPromise<ClusterStatus> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdStatusGet(clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of operator roles.
         * @param {string} [clusterId] 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdStsOperatorRolesGet(clusterId?: string, page?: number, size?: number, options?: any): AxiosPromise<InlineResponse20026> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdStsOperatorRolesGet(clusterId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the operator role.
         * @param {string} [clusterId] 
         * @param {string} [operatorIamRoleId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdStsOperatorRolesOperatorIamRoleIdDelete(clusterId?: string, operatorIamRoleId?: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdStsOperatorRolesOperatorIamRoleIdDelete(clusterId, operatorIamRoleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a new operator role to the cluster.
         * @param {string} [clusterId] 
         * @param {OperatorIAMRole} [operatorIAMRole] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdStsOperatorRolesPost(clusterId?: string, operatorIAMRole?: OperatorIAMRole, options?: any): AxiosPromise<OperatorIAMRole> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdStsOperatorRolesPost(clusterId, operatorIAMRole, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of upgrade policies.
         * @param {string} [clusterId] 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdUpgradePoliciesGet(clusterId?: string, page?: number, size?: number, options?: any): AxiosPromise<InlineResponse20027> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdUpgradePoliciesGet(clusterId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a new upgrade policy to the cluster.
         * @param {string} [clusterId] 
         * @param {UpgradePolicy} [upgradePolicy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdUpgradePoliciesPost(clusterId?: string, upgradePolicy?: UpgradePolicy, options?: any): AxiosPromise<UpgradePolicy> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdUpgradePoliciesPost(clusterId, upgradePolicy, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the upgrade policy.
         * @param {string} [clusterId] 
         * @param {string} [upgradePolicyId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdDelete(clusterId?: string, upgradePolicyId?: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdDelete(clusterId, upgradePolicyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the upgrade policy.
         * @param {string} [clusterId] 
         * @param {string} [upgradePolicyId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdGet(clusterId?: string, upgradePolicyId?: string, options?: any): AxiosPromise<UpgradePolicy> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdGet(clusterId, upgradePolicyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the upgrade policy.
         * @param {string} [clusterId] 
         * @param {string} [upgradePolicyId] 
         * @param {UpgradePolicy} [upgradePolicy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdPatch(clusterId?: string, upgradePolicyId?: string, upgradePolicy?: UpgradePolicy, options?: any): AxiosPromise<UpgradePolicy> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdPatch(clusterId, upgradePolicyId, upgradePolicy, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the upgrade policy state.
         * @param {string} [clusterId] 
         * @param {string} [upgradePolicyId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdStateGet(clusterId?: string, upgradePolicyId?: string, options?: any): AxiosPromise<UpgradePolicyState> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdStateGet(clusterId, upgradePolicyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the upgrade policy state.
         * @param {string} [clusterId] 
         * @param {string} [upgradePolicyId] 
         * @param {UpgradePolicyState} [upgradePolicyState] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdStatePatch(clusterId?: string, upgradePolicyId?: string, upgradePolicyState?: UpgradePolicyState, options?: any): AxiosPromise<UpgradePolicyState> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdStatePatch(clusterId, upgradePolicyId, upgradePolicyState, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of clusters.
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the cluster instead of the names of the columns of a table. For example, in order to sort the clusters descending by region identifier the value should be:  &#x60;&#x60;&#x60;sql region.id desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the cluster instead of the names of the columns of a table. For example, in order to retrieve all the clusters with a name starting with &#x60;my&#x60; in the &#x60;us-east-1&#x60; region the value should be:  &#x60;&#x60;&#x60;sql name like \&#39;my%\&#39; and region.id &#x3D; \&#39;us-east-1\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the clusters that the user has permission to see will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersGet(order?: string, page?: number, search?: string, size?: number, options?: any): AxiosPromise<InlineResponse20011> {
            return localVarFp.apiClustersMgmtV1ClustersGet(order, page, search, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Provision a new cluster and add it to the collection of clusters.  See the `register_cluster` method for adding an existing cluster.
         * @param {Cluster} [cluster] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersPost(cluster?: Cluster, options?: any): AxiosPromise<Cluster> {
            return localVarFp.apiClustersMgmtV1ClustersPost(cluster, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the environment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1EnvironmentGet(options?: any): AxiosPromise<Environment> {
            return localVarFp.apiClustersMgmtV1EnvironmentGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the environment.  Attributes that can be updated are:  - `last_upgrade_available_check` - `last_limited_support_check`
         * @param {Environment} [environment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1EnvironmentPatch(environment?: Environment, options?: any): AxiosPromise<Environment> {
            return localVarFp.apiClustersMgmtV1EnvironmentPatch(environment, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a new event to be tracked. When sending a new event request, it gets tracked in Prometheus, Pendo, CloudWatch, or whichever analytics client is configured as part of clusters service. This allows for reporting on events that happen outside of a regular API request, but are found to be useful for understanding customer needs and possible blockers.
         * @param {Event} [event] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1EventsPost(event?: Event, options?: any): AxiosPromise<Event> {
            return localVarFp.apiClustersMgmtV1EventsPost(event, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the cluster flavour.
         * @param {string} [flavourId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1FlavoursFlavourIdGet(flavourId?: string, options?: any): AxiosPromise<Flavour> {
            return localVarFp.apiClustersMgmtV1FlavoursFlavourIdGet(flavourId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the flavour.  Attributes that can be updated are:  - `aws.infra_volume` - `aws.infra_instance_type` - `gcp.infra_instance_type`
         * @param {string} [flavourId] 
         * @param {Flavour} [flavour] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1FlavoursFlavourIdPatch(flavourId?: string, flavour?: Flavour, options?: any): AxiosPromise<Flavour> {
            return localVarFp.apiClustersMgmtV1FlavoursFlavourIdPatch(flavourId, flavour, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the flavour instead of the names of the columns of a table. For example, in order to sort the flavours descending by name the value should be:  &#x60;&#x60;&#x60;sql name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the flavour instead of the names of the columns of a table. For example, in order to retrieve all the flavours with a name starting with &#x60;my&#x60;the value should be:  &#x60;&#x60;&#x60;sql name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the flavours that the user has permission to see will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1FlavoursGet(order?: string, page?: number, search?: string, size?: number, options?: any): AxiosPromise<InlineResponse20028> {
            return localVarFp.apiClustersMgmtV1FlavoursGet(order, page, search, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a new cluster flavour.
         * @param {Flavour} [flavour] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1FlavoursPost(flavour?: Flavour, options?: any): AxiosPromise<Flavour> {
            return localVarFp.apiClustersMgmtV1FlavoursPost(flavour, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of encryption keys. IMPORTANT: This collection doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of available regions of the provider.
         * @param {number} [page] Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;.
         * @param {number} [size] Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of regions of the provider.
         * @param {CloudProviderData} [cloudProviderData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1GcpInquiriesEncryptionKeysPost(page?: number, size?: number, cloudProviderData?: CloudProviderData, options?: any): AxiosPromise<InlineResponse20029> {
            return localVarFp.apiClustersMgmtV1GcpInquiriesEncryptionKeysPost(page, size, cloudProviderData, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of available key rings of the cloud provider. IMPORTANT: This collection doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of available regions of the provider.
         * @param {number} [page] Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;.
         * @param {number} [size] Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of key rings of the provider.
         * @param {CloudProviderData} [cloudProviderData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1GcpInquiriesKeyRingsPost(page?: number, size?: number, cloudProviderData?: CloudProviderData, options?: any): AxiosPromise<InlineResponse20030> {
            return localVarFp.apiClustersMgmtV1GcpInquiriesKeyRingsPost(page, size, cloudProviderData, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of available regions of the cloud provider. IMPORTANT: This list doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of available regions of the provider.
         * @param {number} [page] Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;.
         * @param {number} [size] Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of regions of the provider.
         * @param {CloudProviderData} [cloudProviderData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1GcpInquiriesRegionsPost(page?: number, size?: number, cloudProviderData?: CloudProviderData, options?: any): AxiosPromise<InlineResponse2004> {
            return localVarFp.apiClustersMgmtV1GcpInquiriesRegionsPost(page, size, cloudProviderData, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of available vpcs of the cloud provider for specific region. IMPORTANT: This collection doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of available vpcs of the provider.
         * @param {number} [page] Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;.
         * @param {number} [size] Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of vpcs of the provider.
         * @param {CloudProviderData} [cloudProviderData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1GcpInquiriesVpcsPost(page?: number, size?: number, cloudProviderData?: CloudProviderData, options?: any): AxiosPromise<InlineResponse2007> {
            return localVarFp.apiClustersMgmtV1GcpInquiriesVpcsPost(page, size, cloudProviderData, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the version metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1Get(options?: any): AxiosPromise<Metadata> {
            return localVarFp.apiClustersMgmtV1Get(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of templates.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1LimitedSupportReasonTemplatesGet(page?: number, size?: number, options?: any): AxiosPromise<InlineResponse20031> {
            return localVarFp.apiClustersMgmtV1LimitedSupportReasonTemplatesGet(page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the template.
         * @param {string} [limitedSupportReasonTemplateId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1LimitedSupportReasonTemplatesLimitedSupportReasonTemplateIdGet(limitedSupportReasonTemplateId?: string, options?: any): AxiosPromise<LimitedSupportReasonTemplate> {
            return localVarFp.apiClustersMgmtV1LimitedSupportReasonTemplatesLimitedSupportReasonTemplateIdGet(limitedSupportReasonTemplateId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of machine types.
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the machine type instead of the names of the columns of a table. For example, in order to sort the machine types descending by name identifier the value should be:  &#x60;&#x60;&#x60;sql name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the machine type instead of the names of the columns of a table. For example, in order to retrieve all the machine types with a name starting with &#x60;A&#x60; the value should be:  &#x60;&#x60;&#x60;sql name like \&#39;A%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the machine types that the user has permission to see will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1MachineTypesGet(order?: string, page?: number, search?: string, size?: number, options?: any): AxiosPromise<InlineResponse20032> {
            return localVarFp.apiClustersMgmtV1MachineTypesGet(order, page, search, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of products.
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the product instead of the names of the columns of a table. For example, in order to sort the products descending by name the value should be:  &#x60;&#x60;&#x60;sql name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the product instead of the names of the columns of a table. For example, in order to retrieve all the products with a name starting with &#x60;my&#x60; the value should be:  &#x60;&#x60;&#x60;sql name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the products that the user has permission to see will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ProductsGet(order?: string, page?: number, search?: string, size?: number, options?: any): AxiosPromise<InlineResponse20033> {
            return localVarFp.apiClustersMgmtV1ProductsGet(order, page, search, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the product.
         * @param {string} [productId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ProductsProductIdGet(productId?: string, options?: any): AxiosPromise<Product> {
            return localVarFp.apiClustersMgmtV1ProductsProductIdGet(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ProvisionShardsGet(page?: number, size?: number, options?: any): AxiosPromise<InlineResponse20034> {
            return localVarFp.apiClustersMgmtV1ProvisionShardsGet(page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the provision shard.
         * @param {string} [provisionShardId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ProvisionShardsProvisionShardIdGet(provisionShardId?: string, options?: any): AxiosPromise<ProvisionShard> {
            return localVarFp.apiClustersMgmtV1ProvisionShardsProvisionShardIdGet(provisionShardId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of version gates.
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of an SQL statement, but using the names of the attributes of the version gate instead of the names of the columns of a table. For example, in order to sort the version gates descending by identifier the value should be:  &#x60;&#x60;&#x60;sql id desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the version gate instead of the names of the columns of a table.  If the parameter isn\&#39;t provided, or if the value is empty, then all the version gates that the user has permission to see will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.  Default value is &#x60;100&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1VersionGatesGet(order?: string, page?: number, search?: string, size?: number, options?: any): AxiosPromise<InlineResponse20035> {
            return localVarFp.apiClustersMgmtV1VersionGatesGet(order, page, search, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a new version gate
         * @param {VersionGate} [versionGate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1VersionGatesPost(versionGate?: VersionGate, options?: any): AxiosPromise<VersionGate> {
            return localVarFp.apiClustersMgmtV1VersionGatesPost(versionGate, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the version gate.
         * @param {string} [versionGateId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1VersionGatesVersionGateIdDelete(versionGateId?: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiClustersMgmtV1VersionGatesVersionGateIdDelete(versionGateId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the version gate.
         * @param {string} [versionGateId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1VersionGatesVersionGateIdGet(versionGateId?: string, options?: any): AxiosPromise<VersionGate> {
            return localVarFp.apiClustersMgmtV1VersionGatesVersionGateIdGet(versionGateId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of versions.
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the version instead of the names of the columns of a table. For example, in order to sort the versions descending by identifier the value should be:  &#x60;&#x60;&#x60;sql id desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the version instead of the names of the columns of a table. For example, in order to retrieve all the versions that are enabled:  &#x60;&#x60;&#x60;sql enabled &#x3D; \&#39;t\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the versions that the user has permission to see will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.  Default value is &#x60;100&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1VersionsGet(order?: string, page?: number, search?: string, size?: number, options?: any): AxiosPromise<InlineResponse20036> {
            return localVarFp.apiClustersMgmtV1VersionsGet(order, page, search, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the version.
         * @param {string} [versionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1VersionsVersionIdGet(versionId?: string, options?: any): AxiosPromise<Version> {
            return localVarFp.apiClustersMgmtV1VersionsVersionIdGet(versionId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - interface
 * @export
 * @interface DefaultApi
 */
export interface DefaultApiInterface {
    /**
     * Deletes the add-on.
     * @param {string} [addonId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1AddonsAddonIdDelete(addonId?: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * Retrieves the details of the add-on.
     * @param {string} [addonId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1AddonsAddonIdGet(addonId?: string, options?: AxiosRequestConfig): AxiosPromise<AddOn>;

    /**
     * Updates the add-on.
     * @param {string} [addonId] 
     * @param {AddOn} [addOn] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1AddonsAddonIdPatch(addonId?: string, addOn?: AddOn, options?: AxiosRequestConfig): AxiosPromise<AddOn>;

    /**
     * Retrieves the list of add-on versions.
     * @param {string} [addonId] 
     * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the add-on instead of the names of the columns of a table. For example, in order to sort the add-on versions descending by id the value should be:  &#x60;&#x60;&#x60;sql id desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
     * @param {number} [page] Index of the requested page, where one corresponds to the first page.
     * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the add-on version instead of the names of the columns of a table. For example, in order to retrieve all the add-on versions with an id starting with &#x60;0.1&#x60; the value should be:  &#x60;&#x60;&#x60;sql id like \&#39;0.1.%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the add-on versions that the user has permission to see will be returned.
     * @param {number} [size] Maximum number of items that will be contained in the returned page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1AddonsAddonIdVersionsGet(addonId?: string, order?: string, page?: number, search?: string, size?: number, options?: AxiosRequestConfig): AxiosPromise<InlineResponse2001>;

    /**
     * Create a new add-on version and add it to the collection of add-ons.
     * @param {string} [addonId] 
     * @param {AddOnVersion} [addOnVersion] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1AddonsAddonIdVersionsPost(addonId?: string, addOnVersion?: AddOnVersion, options?: AxiosRequestConfig): AxiosPromise<AddOnVersion>;

    /**
     * Deletes the add-on version.
     * @param {string} [addonId] 
     * @param {string} [versionId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1AddonsAddonIdVersionsVersionIdDelete(addonId?: string, versionId?: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * Retrieves the details of the add-on version.
     * @param {string} [addonId] 
     * @param {string} [versionId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1AddonsAddonIdVersionsVersionIdGet(addonId?: string, versionId?: string, options?: AxiosRequestConfig): AxiosPromise<AddOnVersion>;

    /**
     * Updates the add-on version.
     * @param {string} [addonId] 
     * @param {string} [versionId] 
     * @param {AddOnVersion} [addOnVersion] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1AddonsAddonIdVersionsVersionIdPatch(addonId?: string, versionId?: string, addOnVersion?: AddOnVersion, options?: AxiosRequestConfig): AxiosPromise<AddOnVersion>;

    /**
     * Retrieves the list of add-ons.
     * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the add-on instead of the names of the columns of a table. For example, in order to sort the add-ons descending by name the value should be:  &#x60;&#x60;&#x60;sql name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
     * @param {number} [page] Index of the requested page, where one corresponds to the first page.
     * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the add-on instead of the names of the columns of a table. For example, in order to retrieve all the add-ons with a name starting with &#x60;my&#x60; the value should be:  &#x60;&#x60;&#x60;sql name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the add-ons that the user has permission to see will be returned.
     * @param {number} [size] Maximum number of items that will be contained in the returned page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1AddonsGet(order?: string, page?: number, search?: string, size?: number, options?: AxiosRequestConfig): AxiosPromise<InlineResponse200>;

    /**
     * Create a new add-on and add it to the collection of add-ons.
     * @param {AddOn} [addOn] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1AddonsPost(addOn?: AddOn, options?: AxiosRequestConfig): AxiosPromise<AddOn>;

    /**
     * Retrieves the details of the aws infrastructure access role.
     * @param {string} [awsInfrastructureAccessRoleId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1AwsInfrastructureAccessRolesAwsInfrastructureAccessRoleIdGet(awsInfrastructureAccessRoleId?: string, options?: AxiosRequestConfig): AxiosPromise<AWSInfrastructureAccessRole>;

    /**
     * 
     * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the role instead of the names of the columns of a table. For example, in order to sort the roles descending by dislay_name the value should be:  &#x60;&#x60;&#x60;sql display_name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
     * @param {number} [page] Index of the requested page, where one corresponds to the first page.
     * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the role instead of the names of the columns of a table. For example, in order to retrieve all the role with a name starting with &#x60;my&#x60;the value should be:  &#x60;&#x60;&#x60;sql display_name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the roles that the user has permission to see will be returned.
     * @param {number} [size] Maximum number of items that will be contained in the returned page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1AwsInfrastructureAccessRolesGet(order?: string, page?: number, search?: string, size?: number, options?: AxiosRequestConfig): AxiosPromise<InlineResponse2002>;

    /**
     * Retrieves the list of machine types in the provided region.
     * @param {number} [page] Index of the requested page, where one corresponds to the first page.
     * @param {number} [size] Maximum number of items that will be contained in the returned page.
     * @param {CloudProviderData} [cloudProviderData] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1AwsInquiriesMachineTypesPost(page?: number, size?: number, cloudProviderData?: CloudProviderData, options?: AxiosRequestConfig): AxiosPromise<InlineResponse2003>;

    /**
     * Retrieves the list of available regions of the cloud provider. IMPORTANT: This list doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of available regions of the provider.
     * @param {number} [page] Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;.
     * @param {number} [size] Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of regions of the provider.
     * @param {CloudProviderData} [cloudProviderData] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1AwsInquiriesRegionsPost(page?: number, size?: number, cloudProviderData?: CloudProviderData, options?: AxiosRequestConfig): AxiosPromise<InlineResponse2004>;

    /**
     * Retrieves the list of policies.
     * @param {number} [page] Index of the requested page, where one corresponds to the first page.
     * @param {number} [size] Maximum number of items that will be contained in the returned page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1AwsInquiriesStsCredentialRequestsGet(page?: number, size?: number, options?: AxiosRequestConfig): AxiosPromise<InlineResponse2005>;

    /**
     * Retrieves the list of policies.
     * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the awsstspolicies instead of the names of the columns of a table. For example, in order to sort the policies descending by operator type identifier the value should be:  &#x60;&#x60;&#x60;sql orderBy id desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
     * @param {number} [page] Index of the requested page, where one corresponds to the first page.
     * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the awsstspolicies instead of the names of the columns of a table. For example, in order to retrieve all the policies of type  &#x60;operatorrole&#x60; should be:  &#x60;&#x60;&#x60;sql policy_type like \&#39;OperatorRole%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the policies  will be returned.
     * @param {number} [size] Maximum number of items that will be contained in the returned page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1AwsInquiriesStsPoliciesGet(order?: string, page?: number, search?: string, size?: number, options?: AxiosRequestConfig): AxiosPromise<InlineResponse2006>;

    /**
     * Retrieves the list of available vpcs of the cloud provider for specific region. IMPORTANT: This collection doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of available vpcs of the provider.
     * @param {number} [page] Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;.
     * @param {number} [size] Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of vpcs of the provider.
     * @param {CloudProviderData} [cloudProviderData] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1AwsInquiriesVpcsPost(page?: number, size?: number, cloudProviderData?: CloudProviderData, options?: AxiosRequestConfig): AxiosPromise<InlineResponse2007>;

    /**
     * Retrieves the list of available regions of the cloud provider.  IMPORTANT: This collection doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of available regions of the provider.
     * @param {string} [cloudProviderId] 
     * @param {number} [page] Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;.
     * @param {number} [size] Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of regions of the provider.
     * @param {AWS} [aWS] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1CloudProvidersCloudProviderIdAvailableRegionsPost(cloudProviderId?: string, page?: number, size?: number, aWS?: AWS, options?: AxiosRequestConfig): AxiosPromise<InlineResponse2009>;

    /**
     * Retrieves the details of the cloud provider.
     * @param {string} [cloudProviderId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1CloudProvidersCloudProviderIdGet(cloudProviderId?: string, options?: AxiosRequestConfig): AxiosPromise<CloudProvider>;

    /**
     * Retrieves the list of regions of the cloud provider.  IMPORTANT: This collection doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of regions of the provider.
     * @param {string} [cloudProviderId] 
     * @param {number} [page] Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;.
     * @param {number} [size] Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of regions of the provider.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsGet(cloudProviderId?: string, page?: number, size?: number, options?: AxiosRequestConfig): AxiosPromise<InlineResponse20010>;

    /**
     * Retrieves the details of the region.
     * @param {string} [cloudProviderId] 
     * @param {string} [regionId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsRegionIdGet(cloudProviderId?: string, regionId?: string, options?: AxiosRequestConfig): AxiosPromise<CloudRegion>;

    /**
     * Retrieves the list of cloud providers.
     * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the cloud provider instead of the names of the columns of a table. For example, in order to sort the clusters descending by name identifier the value should be:  &#x60;&#x60;&#x60;sql name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
     * @param {number} [page] Index of the requested page, where one corresponds to the first page.
     * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the cloud provider instead of the names of the columns of a table. For example, in order to retrieve all the cloud providers with a name starting with &#x60;A&#x60; the value should be:  &#x60;&#x60;&#x60;sql name like \&#39;A%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the clusters that the user has permission to see will be returned.
     * @param {number} [size] Maximum number of items that will be contained in the returned page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1CloudProvidersGet(order?: string, page?: number, search?: string, size?: number, options?: AxiosRequestConfig): AxiosPromise<InlineResponse2008>;

    /**
     * 
     * @param {string} [clusterId] 
     * @param {string} [addonInquiryId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdAddonInquiriesAddonInquiryIdGet(clusterId?: string, addonInquiryId?: string, options?: AxiosRequestConfig): AxiosPromise<AddOn>;

    /**
     * 
     * @param {string} [clusterId] 
     * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the add-on instead of the names of the columns of a table. For example, in order to sort the add-ons descending by name the value should be:  &#x60;&#x60;&#x60;sql name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
     * @param {number} [page] Index of the requested page, where one corresponds to the first page.
     * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the add-on instead of the names of the columns of a table. For example, in order to retrieve all the add-ons with a name starting with &#x60;my&#x60; the value should be:  &#x60;&#x60;&#x60;sql name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the add-ons that the user has permission to see will be returned.
     * @param {number} [size] Maximum number of items that will be contained in the returned page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdAddonInquiriesGet(clusterId?: string, order?: string, page?: number, search?: string, size?: number, options?: AxiosRequestConfig): AxiosPromise<InlineResponse200>;

    /**
     * Delete an add-on installation and remove it from the collection of add-on installations on the cluster.
     * @param {string} [clusterId] 
     * @param {string} [addoninstallationId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdDelete(clusterId?: string, addoninstallationId?: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * Retrieves the details of the add-on installation.
     * @param {string} [clusterId] 
     * @param {string} [addoninstallationId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdGet(clusterId?: string, addoninstallationId?: string, options?: AxiosRequestConfig): AxiosPromise<AddOnInstallation>;

    /**
     * Updates the add-on installation.
     * @param {string} [clusterId] 
     * @param {string} [addoninstallationId] 
     * @param {AddOnInstallation} [addOnInstallation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdPatch(clusterId?: string, addoninstallationId?: string, addOnInstallation?: AddOnInstallation, options?: AxiosRequestConfig): AxiosPromise<AddOnInstallation>;

    /**
     * Retrieves the list of add-on installations.
     * @param {string} [clusterId] 
     * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the add-on installation instead of the names of the columns of a table. For example, in order to sort the add-on installations descending by name the value should be:  &#x60;&#x60;&#x60;sql name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
     * @param {number} [page] Index of the requested page, where one corresponds to the first page.
     * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the add-on installation instead of the names of the columns of a table. For example, in order to retrieve all the add-on installations with a name starting with &#x60;my&#x60; the value should be:  &#x60;&#x60;&#x60;sql name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the add-on installations that the user has permission to see will be returned.
     * @param {number} [size] Maximum number of items that will be contained in the returned page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdAddonsGet(clusterId?: string, order?: string, page?: number, search?: string, size?: number, options?: AxiosRequestConfig): AxiosPromise<InlineResponse20012>;

    /**
     * Create a new add-on installation and add it to the collection of add-on installations on the cluster.
     * @param {string} [clusterId] 
     * @param {AddOnInstallation} [addOnInstallation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdAddonsPost(clusterId?: string, addOnInstallation?: AddOnInstallation, options?: AxiosRequestConfig): AxiosPromise<AddOnInstallation>;

    /**
     * Deletes the AWS infrastructure access role grant.
     * @param {string} [clusterId] 
     * @param {string} [awsInfrastructureAccessRoleGrantId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsAwsInfrastructureAccessRoleGrantIdDelete(clusterId?: string, awsInfrastructureAccessRoleGrantId?: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * Retrieves the details of the AWS infrastructure access role grant.
     * @param {string} [clusterId] 
     * @param {string} [awsInfrastructureAccessRoleGrantId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsAwsInfrastructureAccessRoleGrantIdGet(clusterId?: string, awsInfrastructureAccessRoleGrantId?: string, options?: AxiosRequestConfig): AxiosPromise<AWSInfrastructureAccessRoleGrant>;

    /**
     * Retrieves the list of AWS infrastructure access role grants.
     * @param {string} [clusterId] 
     * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the AWS infrastructure access role grant instead of the names of the columns of a table. For example, in order to sort the AWS infrastructure access role grants descending by user ARN the value should be:  &#x60;&#x60;&#x60;sql user_arn desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
     * @param {number} [page] Index of the requested page, where one corresponds to the first page.
     * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the AWS infrastructure access role grant instead of the names of the columns of a table. For example, in order to retrieve all the AWS infrastructure access role grants with a user ARN starting with &#x60;user&#x60; the value should be:  &#x60;&#x60;&#x60;sql user_arn like \&#39;%user\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the AWS infrastructure access role grants that the user has permission to see will be returned.
     * @param {number} [size] Maximum number of items that will be contained in the returned page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsGet(clusterId?: string, order?: string, page?: number, search?: string, size?: number, options?: AxiosRequestConfig): AxiosPromise<InlineResponse20013>;

    /**
     * Create a new AWS infrastructure access role grant and add it to the collection of AWS infrastructure access role grants on the cluster.
     * @param {string} [clusterId] 
     * @param {AWSInfrastructureAccessRoleGrant} [aWSInfrastructureAccessRoleGrant] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsPost(clusterId?: string, aWSInfrastructureAccessRoleGrant?: AWSInfrastructureAccessRoleGrant, options?: AxiosRequestConfig): AxiosPromise<AWSInfrastructureAccessRoleGrant>;

    /**
     * Deletes the clusterdeployment.
     * @param {string} [clusterId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdClusterdeploymentDelete(clusterId?: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * Retrieves the details of the credentials of a cluster.
     * @param {string} [clusterId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdCredentialsGet(clusterId?: string, options?: AxiosRequestConfig): AxiosPromise<ClusterCredentials>;

    /**
     * Deletes the cluster.
     * @param {string} [clusterId] 
     * @param {boolean} [deprovision] If false it will only delete from OCM but not the actual cluster resources. false is only allowed for OCP clusters. true by default.
     * @param {boolean} [dryRun] Dry run flag is used to check if the operation can be completed, but won\&#39;t delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdDelete(clusterId?: string, deprovision?: boolean, dryRun?: boolean, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * Retrieves the details of the external configuration.
     * @param {string} [clusterId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdExternalConfigurationGet(clusterId?: string, options?: AxiosRequestConfig): AxiosPromise<ExternalConfiguration>;

    /**
     * Retrieves the list of labels.
     * @param {string} [clusterId] 
     * @param {number} [page] Index of the requested page, where one corresponds to the first page.
     * @param {number} [size] Number of items contained in the returned page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsGet(clusterId?: string, page?: number, size?: number, options?: AxiosRequestConfig): AxiosPromise<InlineResponse20014>;

    /**
     * Deletes the label.
     * @param {string} [clusterId] 
     * @param {string} [labelId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdDelete(clusterId?: string, labelId?: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * Retrieves the details of the label.
     * @param {string} [clusterId] 
     * @param {string} [labelId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdGet(clusterId?: string, labelId?: string, options?: AxiosRequestConfig): AxiosPromise<Label>;

    /**
     * Update the label.
     * @param {string} [clusterId] 
     * @param {string} [labelId] 
     * @param {Label} [label] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdPatch(clusterId?: string, labelId?: string, label?: Label, options?: AxiosRequestConfig): AxiosPromise<Label>;

    /**
     * Adds a new label to the cluster.
     * @param {string} [clusterId] 
     * @param {Label} [label] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsPost(clusterId?: string, label?: Label, options?: AxiosRequestConfig): AxiosPromise<Label>;

    /**
     * Retrieves the list of syncsets.
     * @param {string} [clusterId] 
     * @param {number} [page] Index of the requested page, where one corresponds to the first page.
     * @param {number} [size] Number of items contained in the returned page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsGet(clusterId?: string, page?: number, size?: number, options?: AxiosRequestConfig): AxiosPromise<InlineResponse20015>;

    /**
     * Adds a new syncset to the cluster.
     * @param {string} [clusterId] 
     * @param {Syncset} [syncset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsPost(clusterId?: string, syncset?: Syncset, options?: AxiosRequestConfig): AxiosPromise<Syncset>;

    /**
     * Deletes the syncset.
     * @param {string} [clusterId] 
     * @param {string} [syncsetId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdDelete(clusterId?: string, syncsetId?: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * Retrieves the details of the syncset.
     * @param {string} [clusterId] 
     * @param {string} [syncsetId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdGet(clusterId?: string, syncsetId?: string, options?: AxiosRequestConfig): AxiosPromise<Syncset>;

    /**
     * Update the syncset.
     * @param {string} [clusterId] 
     * @param {string} [syncsetId] 
     * @param {Syncset} [syncset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdPatch(clusterId?: string, syncsetId?: string, syncset?: Syncset, options?: AxiosRequestConfig): AxiosPromise<Syncset>;

    /**
     * Retrieves the list of reasons.
     * @param {string} [clusterId] 
     * @param {number} [page] Index of the requested page, where one corresponds to the first page.
     * @param {number} [size] Number of items contained in the returned page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdGateAgreementsGet(clusterId?: string, page?: number, size?: number, options?: AxiosRequestConfig): AxiosPromise<InlineResponse20016>;

    /**
     * Adds a new agreed version gate to the cluster.
     * @param {string} [clusterId] 
     * @param {VersionGateAgreement} [versionGateAgreement] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdGateAgreementsPost(clusterId?: string, versionGateAgreement?: VersionGateAgreement, options?: AxiosRequestConfig): AxiosPromise<VersionGateAgreement>;

    /**
     * Deletes the version gate agreement.
     * @param {string} [clusterId] 
     * @param {string} [versionGateAgreementId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdGateAgreementsVersionGateAgreementIdDelete(clusterId?: string, versionGateAgreementId?: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * Retrieves the details of the version gate agreement.
     * @param {string} [clusterId] 
     * @param {string} [versionGateAgreementId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdGateAgreementsVersionGateAgreementIdGet(clusterId?: string, versionGateAgreementId?: string, options?: AxiosRequestConfig): AxiosPromise<VersionGateAgreement>;

    /**
     * Retrieves the details of the cluster.
     * @param {string} [clusterId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdGet(clusterId?: string, options?: AxiosRequestConfig): AxiosPromise<Cluster>;

    /**
     * Retrieves the list of groups.
     * @param {string} [clusterId] 
     * @param {number} [page] Index of the requested page, where one corresponds to the first page.
     * @param {number} [size] Number of items contained in the returned page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdGroupsGet(clusterId?: string, page?: number, size?: number, options?: AxiosRequestConfig): AxiosPromise<InlineResponse20017>;

    /**
     * Retrieves the details of the group.
     * @param {string} [clusterId] 
     * @param {string} [groupId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdGroupsGroupIdGet(clusterId?: string, groupId?: string, options?: AxiosRequestConfig): AxiosPromise<Group>;

    /**
     * Retrieves the list of users.
     * @param {string} [clusterId] 
     * @param {string} [groupId] 
     * @param {number} [page] Index of the requested page, where one corresponds to the first page.
     * @param {number} [size] Number of items contained in the returned page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersGet(clusterId?: string, groupId?: string, page?: number, size?: number, options?: AxiosRequestConfig): AxiosPromise<InlineResponse20018>;

    /**
     * Adds a new user to the group.
     * @param {string} [clusterId] 
     * @param {string} [groupId] 
     * @param {User} [user] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersPost(clusterId?: string, groupId?: string, user?: User, options?: AxiosRequestConfig): AxiosPromise<User>;

    /**
     * Deletes the user.
     * @param {string} [clusterId] 
     * @param {string} [groupId] 
     * @param {string} [userId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdDelete(clusterId?: string, groupId?: string, userId?: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * Retrieves the details of the user.
     * @param {string} [clusterId] 
     * @param {string} [groupId] 
     * @param {string} [userId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdGet(clusterId?: string, groupId?: string, userId?: string, options?: AxiosRequestConfig): AxiosPromise<User>;

    /**
     * Initiates cluster hibernation. While hibernating a cluster will not consume any cloud provider infrastructure but will be counted for quota.
     * @param {string} [clusterId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdHibernatePost(clusterId?: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * Retrieves the list of identity providers.
     * @param {string} [clusterId] 
     * @param {number} [page] Index of the requested page, where one corresponds to the first page.
     * @param {number} [size] Number of items contained in the returned page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdIdentityProvidersGet(clusterId?: string, page?: number, size?: number, options?: AxiosRequestConfig): AxiosPromise<InlineResponse20019>;

    /**
     * Deletes the identity provider.
     * @param {string} [clusterId] 
     * @param {string} [identityProviderId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdDelete(clusterId?: string, identityProviderId?: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * Retrieves the details of the identity provider.
     * @param {string} [clusterId] 
     * @param {string} [identityProviderId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdGet(clusterId?: string, identityProviderId?: string, options?: AxiosRequestConfig): AxiosPromise<IdentityProvider>;

    /**
     * Retrieves the list of _HTPasswd_ IDP users.
     * @param {string} [clusterId] 
     * @param {string} [identityProviderId] 
     * @param {number} [page] Index of the requested page, where one corresponds to the first page.
     * @param {number} [size] Number of items contained in the returned page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersGet(clusterId?: string, identityProviderId?: string, page?: number, size?: number, options?: AxiosRequestConfig): AxiosPromise<InlineResponse20020>;

    /**
     * Deletes the user.
     * @param {string} [clusterId] 
     * @param {string} [identityProviderId] 
     * @param {string} [htpasswdUserId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdDelete(clusterId?: string, identityProviderId?: string, htpasswdUserId?: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * Retrieves the details of the user.
     * @param {string} [clusterId] 
     * @param {string} [identityProviderId] 
     * @param {string} [htpasswdUserId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdGet(clusterId?: string, identityProviderId?: string, htpasswdUserId?: string, options?: AxiosRequestConfig): AxiosPromise<HTPasswdUser>;

    /**
     * Updates the user\'s password. The username is not editable
     * @param {string} [clusterId] 
     * @param {string} [identityProviderId] 
     * @param {string} [htpasswdUserId] 
     * @param {HTPasswdUser} [hTPasswdUser] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdPatch(clusterId?: string, identityProviderId?: string, htpasswdUserId?: string, hTPasswdUser?: HTPasswdUser, options?: AxiosRequestConfig): AxiosPromise<HTPasswdUser>;

    /**
     * Adds multiple new users to the _HTPasswd_ file.
     * @param {string} [clusterId] 
     * @param {string} [identityProviderId] 
     * @param {InlineObject} [inlineObject] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersImportPost(clusterId?: string, identityProviderId?: string, inlineObject?: InlineObject, options?: AxiosRequestConfig): AxiosPromise<InlineResponse20021>;

    /**
     * Adds a new user to the _HTPasswd_ file.
     * @param {string} [clusterId] 
     * @param {string} [identityProviderId] 
     * @param {HTPasswdUser} [hTPasswdUser] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersPost(clusterId?: string, identityProviderId?: string, hTPasswdUser?: HTPasswdUser, options?: AxiosRequestConfig): AxiosPromise<HTPasswdUser>;

    /**
     * Update identity provider in the cluster.
     * @param {string} [clusterId] 
     * @param {string} [identityProviderId] 
     * @param {IdentityProvider} [identityProvider] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdPatch(clusterId?: string, identityProviderId?: string, identityProvider?: IdentityProvider, options?: AxiosRequestConfig): AxiosPromise<IdentityProvider>;

    /**
     * Adds a new identity provider to the cluster.
     * @param {string} [clusterId] 
     * @param {IdentityProvider} [identityProvider] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdIdentityProvidersPost(clusterId?: string, identityProvider?: IdentityProvider, options?: AxiosRequestConfig): AxiosPromise<IdentityProvider>;

    /**
     * Retrieves the list of ingresses.
     * @param {string} [clusterId] 
     * @param {number} [page] Index of the requested page, where one corresponds to the first page.
     * @param {number} [size] Number of items contained in the returned page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdIngressesGet(clusterId?: string, page?: number, size?: number, options?: AxiosRequestConfig): AxiosPromise<InlineResponse20022>;

    /**
     * Deletes the ingress.
     * @param {string} [clusterId] 
     * @param {string} [ingressId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdIngressesIngressIdDelete(clusterId?: string, ingressId?: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * Retrieves the details of the ingress.
     * @param {string} [clusterId] 
     * @param {string} [ingressId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdIngressesIngressIdGet(clusterId?: string, ingressId?: string, options?: AxiosRequestConfig): AxiosPromise<Ingress>;

    /**
     * Updates the ingress.
     * @param {string} [clusterId] 
     * @param {string} [ingressId] 
     * @param {Ingress} [ingress] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdIngressesIngressIdPatch(clusterId?: string, ingressId?: string, ingress?: Ingress, options?: AxiosRequestConfig): AxiosPromise<Ingress>;

    /**
     * Updates all ingresses
     * @param {string} [clusterId] 
     * @param {Array<Ingress>} [ingress] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdIngressesPatch(clusterId?: string, ingress?: Array<Ingress>, options?: AxiosRequestConfig): AxiosPromise<Array<Ingress>>;

    /**
     * Adds a new ingress to the cluster.
     * @param {string} [clusterId] 
     * @param {Ingress} [ingress] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdIngressesPost(clusterId?: string, ingress?: Ingress, options?: AxiosRequestConfig): AxiosPromise<Ingress>;

    /**
     * Retrieves the list of reasons.
     * @param {string} [clusterId] 
     * @param {number} [page] Index of the requested page, where one corresponds to the first page.
     * @param {number} [size] Number of items contained in the returned page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsGet(clusterId?: string, page?: number, size?: number, options?: AxiosRequestConfig): AxiosPromise<InlineResponse20023>;

    /**
     * Deletes the reason.
     * @param {string} [clusterId] 
     * @param {string} [limitedSupportReasonId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsLimitedSupportReasonIdDelete(clusterId?: string, limitedSupportReasonId?: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * Retrieves the details of the reason.
     * @param {string} [clusterId] 
     * @param {string} [limitedSupportReasonId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsLimitedSupportReasonIdGet(clusterId?: string, limitedSupportReasonId?: string, options?: AxiosRequestConfig): AxiosPromise<LimitedSupportReason>;

    /**
     * Adds a new reason to the cluster.
     * @param {string} [clusterId] 
     * @param {LimitedSupportReason} [limitedSupportReason] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsPost(clusterId?: string, limitedSupportReason?: LimitedSupportReason, options?: AxiosRequestConfig): AxiosPromise<LimitedSupportReason>;

    /**
     * Retrieves the list of log links.
     * @param {string} [clusterId] 
     * @param {number} [page] Index of the requested page, where one corresponds to the first page.
     * @param {number} [size] Number of items contained in the returned page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdLogsGet(clusterId?: string, page?: number, size?: number, options?: AxiosRequestConfig): AxiosPromise<InlineResponse20024>;

    /**
     * Retrieves the details of the log.
     * @param {string} [clusterId] 
     * @param {number} [offset] Line offset to start logs from. if 0 retreive entire log. If offset &gt; #lines return an empty log.
     * @param {number} [tail] Returns the number of tail lines from the end of the log. If there are no line breaks or the number of lines &lt; tail return the entire log. Either \&#39;tail\&#39; or \&#39;offset\&#39; can be set. Not both. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdLogsInstallGet(clusterId?: string, offset?: number, tail?: number, options?: AxiosRequestConfig): AxiosPromise<Log>;

    /**
     * Retrieves the details of the log.
     * @param {string} [clusterId] 
     * @param {number} [offset] Line offset to start logs from. if 0 retreive entire log. If offset &gt; #lines return an empty log.
     * @param {number} [tail] Returns the number of tail lines from the end of the log. If there are no line breaks or the number of lines &lt; tail return the entire log. Either \&#39;tail\&#39; or \&#39;offset\&#39; can be set. Not both. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdLogsUninstallGet(clusterId?: string, offset?: number, tail?: number, options?: AxiosRequestConfig): AxiosPromise<Log>;

    /**
     * Retrieves the list of machine pools.
     * @param {string} [clusterId] 
     * @param {number} [page] Index of the requested page, where one corresponds to the first page.
     * @param {number} [size] Number of items contained in the returned page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdMachinePoolsGet(clusterId?: string, page?: number, size?: number, options?: AxiosRequestConfig): AxiosPromise<InlineResponse20025>;

    /**
     * Deletes the machine pool.
     * @param {string} [clusterId] 
     * @param {string} [machinePoolId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdDelete(clusterId?: string, machinePoolId?: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * Retrieves the details of the machine pool.
     * @param {string} [clusterId] 
     * @param {string} [machinePoolId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdGet(clusterId?: string, machinePoolId?: string, options?: AxiosRequestConfig): AxiosPromise<MachinePool>;

    /**
     * Updates the machine pool.
     * @param {string} [clusterId] 
     * @param {string} [machinePoolId] 
     * @param {MachinePool} [machinePool] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdPatch(clusterId?: string, machinePoolId?: string, machinePool?: MachinePool, options?: AxiosRequestConfig): AxiosPromise<MachinePool>;

    /**
     * Adds a new machine pool to the cluster.
     * @param {string} [clusterId] 
     * @param {MachinePool} [machinePool] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdMachinePoolsPost(clusterId?: string, machinePool?: MachinePool, options?: AxiosRequestConfig): AxiosPromise<MachinePool>;

    /**
     * 
     * @param {string} [clusterId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdMetricQueriesAlertsGet(clusterId?: string, options?: AxiosRequestConfig): AxiosPromise<AlertsInfo>;

    /**
     * 
     * @param {string} [clusterId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdMetricQueriesClusterOperatorsGet(clusterId?: string, options?: AxiosRequestConfig): AxiosPromise<ClusterOperatorsInfo>;

    /**
     * Retrieves the metrics.
     * @param {string} [clusterId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdMetricQueriesCpuTotalByNodeRolesOsGet(clusterId?: string, options?: AxiosRequestConfig): AxiosPromise<CPUTotalsNodeRoleOSMetricNode>;

    /**
     * 
     * @param {string} [clusterId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdMetricQueriesNodesGet(clusterId?: string, options?: AxiosRequestConfig): AxiosPromise<NodesInfo>;

    /**
     * Retrieves the metrics.
     * @param {string} [clusterId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdMetricQueriesSocketTotalByNodeRolesOsGet(clusterId?: string, options?: AxiosRequestConfig): AxiosPromise<SocketTotalsNodeRoleOSMetricNode>;

    /**
     * Updates the cluster.
     * @param {string} [clusterId] 
     * @param {Cluster} [cluster] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdPatch(clusterId?: string, cluster?: Cluster, options?: AxiosRequestConfig): AxiosPromise<Cluster>;

    /**
     * Retrieves the details of the product.
     * @param {string} [clusterId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdProductGet(clusterId?: string, options?: AxiosRequestConfig): AxiosPromise<Product>;

    /**
     * Retrieves the details of the provision shard.
     * @param {string} [clusterId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdProvisionShardGet(clusterId?: string, options?: AxiosRequestConfig): AxiosPromise<ProvisionShard>;

    /**
     * Retrieves a list of resources for a cluster in error state
     * @param {string} [clusterId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdResourcesGet(clusterId?: string, options?: AxiosRequestConfig): AxiosPromise<ClusterResources>;

    /**
     * Retrieves currently available cluster resources
     * @param {string} [clusterId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdResourcesLiveGet(clusterId?: string, options?: AxiosRequestConfig): AxiosPromise<ClusterResources>;

    /**
     * Resumes from Hibernation.
     * @param {string} [clusterId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdResumePost(clusterId?: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} [clusterId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdStatusGet(clusterId?: string, options?: AxiosRequestConfig): AxiosPromise<ClusterStatus>;

    /**
     * Retrieves the list of operator roles.
     * @param {string} [clusterId] 
     * @param {number} [page] Index of the requested page, where one corresponds to the first page.
     * @param {number} [size] Number of items that will be contained in the returned page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdStsOperatorRolesGet(clusterId?: string, page?: number, size?: number, options?: AxiosRequestConfig): AxiosPromise<InlineResponse20026>;

    /**
     * Deletes the operator role.
     * @param {string} [clusterId] 
     * @param {string} [operatorIamRoleId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdStsOperatorRolesOperatorIamRoleIdDelete(clusterId?: string, operatorIamRoleId?: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * Adds a new operator role to the cluster.
     * @param {string} [clusterId] 
     * @param {OperatorIAMRole} [operatorIAMRole] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdStsOperatorRolesPost(clusterId?: string, operatorIAMRole?: OperatorIAMRole, options?: AxiosRequestConfig): AxiosPromise<OperatorIAMRole>;

    /**
     * Retrieves the list of upgrade policies.
     * @param {string} [clusterId] 
     * @param {number} [page] Index of the requested page, where one corresponds to the first page.
     * @param {number} [size] Number of items contained in the returned page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdUpgradePoliciesGet(clusterId?: string, page?: number, size?: number, options?: AxiosRequestConfig): AxiosPromise<InlineResponse20027>;

    /**
     * Adds a new upgrade policy to the cluster.
     * @param {string} [clusterId] 
     * @param {UpgradePolicy} [upgradePolicy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdUpgradePoliciesPost(clusterId?: string, upgradePolicy?: UpgradePolicy, options?: AxiosRequestConfig): AxiosPromise<UpgradePolicy>;

    /**
     * Deletes the upgrade policy.
     * @param {string} [clusterId] 
     * @param {string} [upgradePolicyId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdDelete(clusterId?: string, upgradePolicyId?: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * Retrieves the details of the upgrade policy.
     * @param {string} [clusterId] 
     * @param {string} [upgradePolicyId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdGet(clusterId?: string, upgradePolicyId?: string, options?: AxiosRequestConfig): AxiosPromise<UpgradePolicy>;

    /**
     * Update the upgrade policy.
     * @param {string} [clusterId] 
     * @param {string} [upgradePolicyId] 
     * @param {UpgradePolicy} [upgradePolicy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdPatch(clusterId?: string, upgradePolicyId?: string, upgradePolicy?: UpgradePolicy, options?: AxiosRequestConfig): AxiosPromise<UpgradePolicy>;

    /**
     * Retrieves the details of the upgrade policy state.
     * @param {string} [clusterId] 
     * @param {string} [upgradePolicyId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdStateGet(clusterId?: string, upgradePolicyId?: string, options?: AxiosRequestConfig): AxiosPromise<UpgradePolicyState>;

    /**
     * Update the upgrade policy state.
     * @param {string} [clusterId] 
     * @param {string} [upgradePolicyId] 
     * @param {UpgradePolicyState} [upgradePolicyState] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdStatePatch(clusterId?: string, upgradePolicyId?: string, upgradePolicyState?: UpgradePolicyState, options?: AxiosRequestConfig): AxiosPromise<UpgradePolicyState>;

    /**
     * Retrieves the list of clusters.
     * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the cluster instead of the names of the columns of a table. For example, in order to sort the clusters descending by region identifier the value should be:  &#x60;&#x60;&#x60;sql region.id desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
     * @param {number} [page] Index of the requested page, where one corresponds to the first page.
     * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the cluster instead of the names of the columns of a table. For example, in order to retrieve all the clusters with a name starting with &#x60;my&#x60; in the &#x60;us-east-1&#x60; region the value should be:  &#x60;&#x60;&#x60;sql name like \&#39;my%\&#39; and region.id &#x3D; \&#39;us-east-1\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the clusters that the user has permission to see will be returned.
     * @param {number} [size] Maximum number of items that will be contained in the returned page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersGet(order?: string, page?: number, search?: string, size?: number, options?: AxiosRequestConfig): AxiosPromise<InlineResponse20011>;

    /**
     * Provision a new cluster and add it to the collection of clusters.  See the `register_cluster` method for adding an existing cluster.
     * @param {Cluster} [cluster] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersPost(cluster?: Cluster, options?: AxiosRequestConfig): AxiosPromise<Cluster>;

    /**
     * Retrieves the details of the environment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1EnvironmentGet(options?: AxiosRequestConfig): AxiosPromise<Environment>;

    /**
     * Updates the environment.  Attributes that can be updated are:  - `last_upgrade_available_check` - `last_limited_support_check`
     * @param {Environment} [environment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1EnvironmentPatch(environment?: Environment, options?: AxiosRequestConfig): AxiosPromise<Environment>;

    /**
     * Adds a new event to be tracked. When sending a new event request, it gets tracked in Prometheus, Pendo, CloudWatch, or whichever analytics client is configured as part of clusters service. This allows for reporting on events that happen outside of a regular API request, but are found to be useful for understanding customer needs and possible blockers.
     * @param {Event} [event] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1EventsPost(event?: Event, options?: AxiosRequestConfig): AxiosPromise<Event>;

    /**
     * Retrieves the details of the cluster flavour.
     * @param {string} [flavourId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1FlavoursFlavourIdGet(flavourId?: string, options?: AxiosRequestConfig): AxiosPromise<Flavour>;

    /**
     * Updates the flavour.  Attributes that can be updated are:  - `aws.infra_volume` - `aws.infra_instance_type` - `gcp.infra_instance_type`
     * @param {string} [flavourId] 
     * @param {Flavour} [flavour] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1FlavoursFlavourIdPatch(flavourId?: string, flavour?: Flavour, options?: AxiosRequestConfig): AxiosPromise<Flavour>;

    /**
     * 
     * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the flavour instead of the names of the columns of a table. For example, in order to sort the flavours descending by name the value should be:  &#x60;&#x60;&#x60;sql name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
     * @param {number} [page] Index of the requested page, where one corresponds to the first page.
     * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the flavour instead of the names of the columns of a table. For example, in order to retrieve all the flavours with a name starting with &#x60;my&#x60;the value should be:  &#x60;&#x60;&#x60;sql name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the flavours that the user has permission to see will be returned.
     * @param {number} [size] Maximum number of items that will be contained in the returned page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1FlavoursGet(order?: string, page?: number, search?: string, size?: number, options?: AxiosRequestConfig): AxiosPromise<InlineResponse20028>;

    /**
     * Adds a new cluster flavour.
     * @param {Flavour} [flavour] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1FlavoursPost(flavour?: Flavour, options?: AxiosRequestConfig): AxiosPromise<Flavour>;

    /**
     * Retrieves the list of encryption keys. IMPORTANT: This collection doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of available regions of the provider.
     * @param {number} [page] Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;.
     * @param {number} [size] Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of regions of the provider.
     * @param {CloudProviderData} [cloudProviderData] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1GcpInquiriesEncryptionKeysPost(page?: number, size?: number, cloudProviderData?: CloudProviderData, options?: AxiosRequestConfig): AxiosPromise<InlineResponse20029>;

    /**
     * Retrieves the list of available key rings of the cloud provider. IMPORTANT: This collection doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of available regions of the provider.
     * @param {number} [page] Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;.
     * @param {number} [size] Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of key rings of the provider.
     * @param {CloudProviderData} [cloudProviderData] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1GcpInquiriesKeyRingsPost(page?: number, size?: number, cloudProviderData?: CloudProviderData, options?: AxiosRequestConfig): AxiosPromise<InlineResponse20030>;

    /**
     * Retrieves the list of available regions of the cloud provider. IMPORTANT: This list doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of available regions of the provider.
     * @param {number} [page] Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;.
     * @param {number} [size] Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of regions of the provider.
     * @param {CloudProviderData} [cloudProviderData] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1GcpInquiriesRegionsPost(page?: number, size?: number, cloudProviderData?: CloudProviderData, options?: AxiosRequestConfig): AxiosPromise<InlineResponse2004>;

    /**
     * Retrieves the list of available vpcs of the cloud provider for specific region. IMPORTANT: This collection doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of available vpcs of the provider.
     * @param {number} [page] Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;.
     * @param {number} [size] Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of vpcs of the provider.
     * @param {CloudProviderData} [cloudProviderData] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1GcpInquiriesVpcsPost(page?: number, size?: number, cloudProviderData?: CloudProviderData, options?: AxiosRequestConfig): AxiosPromise<InlineResponse2007>;

    /**
     * Retrieves the version metadata.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1Get(options?: AxiosRequestConfig): AxiosPromise<Metadata>;

    /**
     * Retrieves the list of templates.
     * @param {number} [page] Index of the requested page, where one corresponds to the first page.
     * @param {number} [size] Number of items contained in the returned page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1LimitedSupportReasonTemplatesGet(page?: number, size?: number, options?: AxiosRequestConfig): AxiosPromise<InlineResponse20031>;

    /**
     * Retrieves the details of the template.
     * @param {string} [limitedSupportReasonTemplateId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1LimitedSupportReasonTemplatesLimitedSupportReasonTemplateIdGet(limitedSupportReasonTemplateId?: string, options?: AxiosRequestConfig): AxiosPromise<LimitedSupportReasonTemplate>;

    /**
     * Retrieves the list of machine types.
     * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the machine type instead of the names of the columns of a table. For example, in order to sort the machine types descending by name identifier the value should be:  &#x60;&#x60;&#x60;sql name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
     * @param {number} [page] Index of the requested page, where one corresponds to the first page.
     * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the machine type instead of the names of the columns of a table. For example, in order to retrieve all the machine types with a name starting with &#x60;A&#x60; the value should be:  &#x60;&#x60;&#x60;sql name like \&#39;A%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the machine types that the user has permission to see will be returned.
     * @param {number} [size] Maximum number of items that will be contained in the returned page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1MachineTypesGet(order?: string, page?: number, search?: string, size?: number, options?: AxiosRequestConfig): AxiosPromise<InlineResponse20032>;

    /**
     * Retrieves the list of products.
     * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the product instead of the names of the columns of a table. For example, in order to sort the products descending by name the value should be:  &#x60;&#x60;&#x60;sql name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
     * @param {number} [page] Index of the requested page, where one corresponds to the first page.
     * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the product instead of the names of the columns of a table. For example, in order to retrieve all the products with a name starting with &#x60;my&#x60; the value should be:  &#x60;&#x60;&#x60;sql name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the products that the user has permission to see will be returned.
     * @param {number} [size] Maximum number of items that will be contained in the returned page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ProductsGet(order?: string, page?: number, search?: string, size?: number, options?: AxiosRequestConfig): AxiosPromise<InlineResponse20033>;

    /**
     * Retrieves the details of the product.
     * @param {string} [productId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ProductsProductIdGet(productId?: string, options?: AxiosRequestConfig): AxiosPromise<Product>;

    /**
     * 
     * @param {number} [page] Index of the requested page, where one corresponds to the first page.
     * @param {number} [size] Maximum number of items that will be contained in the returned page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ProvisionShardsGet(page?: number, size?: number, options?: AxiosRequestConfig): AxiosPromise<InlineResponse20034>;

    /**
     * Retrieves the details of the provision shard.
     * @param {string} [provisionShardId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ProvisionShardsProvisionShardIdGet(provisionShardId?: string, options?: AxiosRequestConfig): AxiosPromise<ProvisionShard>;

    /**
     * Retrieves a list of version gates.
     * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of an SQL statement, but using the names of the attributes of the version gate instead of the names of the columns of a table. For example, in order to sort the version gates descending by identifier the value should be:  &#x60;&#x60;&#x60;sql id desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
     * @param {number} [page] Index of the requested page, where one corresponds to the first page.
     * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the version gate instead of the names of the columns of a table.  If the parameter isn\&#39;t provided, or if the value is empty, then all the version gates that the user has permission to see will be returned.
     * @param {number} [size] Maximum number of items that will be contained in the returned page.  Default value is &#x60;100&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1VersionGatesGet(order?: string, page?: number, search?: string, size?: number, options?: AxiosRequestConfig): AxiosPromise<InlineResponse20035>;

    /**
     * Adds a new version gate
     * @param {VersionGate} [versionGate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1VersionGatesPost(versionGate?: VersionGate, options?: AxiosRequestConfig): AxiosPromise<VersionGate>;

    /**
     * Deletes the version gate.
     * @param {string} [versionGateId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1VersionGatesVersionGateIdDelete(versionGateId?: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * Retrieves the details of the version gate.
     * @param {string} [versionGateId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1VersionGatesVersionGateIdGet(versionGateId?: string, options?: AxiosRequestConfig): AxiosPromise<VersionGate>;

    /**
     * Retrieves a list of versions.
     * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the version instead of the names of the columns of a table. For example, in order to sort the versions descending by identifier the value should be:  &#x60;&#x60;&#x60;sql id desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
     * @param {number} [page] Index of the requested page, where one corresponds to the first page.
     * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the version instead of the names of the columns of a table. For example, in order to retrieve all the versions that are enabled:  &#x60;&#x60;&#x60;sql enabled &#x3D; \&#39;t\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the versions that the user has permission to see will be returned.
     * @param {number} [size] Maximum number of items that will be contained in the returned page.  Default value is &#x60;100&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1VersionsGet(order?: string, page?: number, search?: string, size?: number, options?: AxiosRequestConfig): AxiosPromise<InlineResponse20036>;

    /**
     * Retrieves the details of the version.
     * @param {string} [versionId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1VersionsVersionIdGet(versionId?: string, options?: AxiosRequestConfig): AxiosPromise<Version>;

}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI implements DefaultApiInterface {
    /**
     * Deletes the add-on.
     * @param {string} [addonId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1AddonsAddonIdDelete(addonId?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1AddonsAddonIdDelete(addonId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the add-on.
     * @param {string} [addonId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1AddonsAddonIdGet(addonId?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1AddonsAddonIdGet(addonId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the add-on.
     * @param {string} [addonId] 
     * @param {AddOn} [addOn] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1AddonsAddonIdPatch(addonId?: string, addOn?: AddOn, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1AddonsAddonIdPatch(addonId, addOn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of add-on versions.
     * @param {string} [addonId] 
     * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the add-on instead of the names of the columns of a table. For example, in order to sort the add-on versions descending by id the value should be:  &#x60;&#x60;&#x60;sql id desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
     * @param {number} [page] Index of the requested page, where one corresponds to the first page.
     * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the add-on version instead of the names of the columns of a table. For example, in order to retrieve all the add-on versions with an id starting with &#x60;0.1&#x60; the value should be:  &#x60;&#x60;&#x60;sql id like \&#39;0.1.%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the add-on versions that the user has permission to see will be returned.
     * @param {number} [size] Maximum number of items that will be contained in the returned page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1AddonsAddonIdVersionsGet(addonId?: string, order?: string, page?: number, search?: string, size?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1AddonsAddonIdVersionsGet(addonId, order, page, search, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new add-on version and add it to the collection of add-ons.
     * @param {string} [addonId] 
     * @param {AddOnVersion} [addOnVersion] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1AddonsAddonIdVersionsPost(addonId?: string, addOnVersion?: AddOnVersion, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1AddonsAddonIdVersionsPost(addonId, addOnVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the add-on version.
     * @param {string} [addonId] 
     * @param {string} [versionId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1AddonsAddonIdVersionsVersionIdDelete(addonId?: string, versionId?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1AddonsAddonIdVersionsVersionIdDelete(addonId, versionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the add-on version.
     * @param {string} [addonId] 
     * @param {string} [versionId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1AddonsAddonIdVersionsVersionIdGet(addonId?: string, versionId?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1AddonsAddonIdVersionsVersionIdGet(addonId, versionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the add-on version.
     * @param {string} [addonId] 
     * @param {string} [versionId] 
     * @param {AddOnVersion} [addOnVersion] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1AddonsAddonIdVersionsVersionIdPatch(addonId?: string, versionId?: string, addOnVersion?: AddOnVersion, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1AddonsAddonIdVersionsVersionIdPatch(addonId, versionId, addOnVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of add-ons.
     * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the add-on instead of the names of the columns of a table. For example, in order to sort the add-ons descending by name the value should be:  &#x60;&#x60;&#x60;sql name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
     * @param {number} [page] Index of the requested page, where one corresponds to the first page.
     * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the add-on instead of the names of the columns of a table. For example, in order to retrieve all the add-ons with a name starting with &#x60;my&#x60; the value should be:  &#x60;&#x60;&#x60;sql name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the add-ons that the user has permission to see will be returned.
     * @param {number} [size] Maximum number of items that will be contained in the returned page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1AddonsGet(order?: string, page?: number, search?: string, size?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1AddonsGet(order, page, search, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new add-on and add it to the collection of add-ons.
     * @param {AddOn} [addOn] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1AddonsPost(addOn?: AddOn, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1AddonsPost(addOn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the aws infrastructure access role.
     * @param {string} [awsInfrastructureAccessRoleId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1AwsInfrastructureAccessRolesAwsInfrastructureAccessRoleIdGet(awsInfrastructureAccessRoleId?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1AwsInfrastructureAccessRolesAwsInfrastructureAccessRoleIdGet(awsInfrastructureAccessRoleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the role instead of the names of the columns of a table. For example, in order to sort the roles descending by dislay_name the value should be:  &#x60;&#x60;&#x60;sql display_name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
     * @param {number} [page] Index of the requested page, where one corresponds to the first page.
     * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the role instead of the names of the columns of a table. For example, in order to retrieve all the role with a name starting with &#x60;my&#x60;the value should be:  &#x60;&#x60;&#x60;sql display_name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the roles that the user has permission to see will be returned.
     * @param {number} [size] Maximum number of items that will be contained in the returned page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1AwsInfrastructureAccessRolesGet(order?: string, page?: number, search?: string, size?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1AwsInfrastructureAccessRolesGet(order, page, search, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of machine types in the provided region.
     * @param {number} [page] Index of the requested page, where one corresponds to the first page.
     * @param {number} [size] Maximum number of items that will be contained in the returned page.
     * @param {CloudProviderData} [cloudProviderData] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1AwsInquiriesMachineTypesPost(page?: number, size?: number, cloudProviderData?: CloudProviderData, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1AwsInquiriesMachineTypesPost(page, size, cloudProviderData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of available regions of the cloud provider. IMPORTANT: This list doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of available regions of the provider.
     * @param {number} [page] Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;.
     * @param {number} [size] Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of regions of the provider.
     * @param {CloudProviderData} [cloudProviderData] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1AwsInquiriesRegionsPost(page?: number, size?: number, cloudProviderData?: CloudProviderData, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1AwsInquiriesRegionsPost(page, size, cloudProviderData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of policies.
     * @param {number} [page] Index of the requested page, where one corresponds to the first page.
     * @param {number} [size] Maximum number of items that will be contained in the returned page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1AwsInquiriesStsCredentialRequestsGet(page?: number, size?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1AwsInquiriesStsCredentialRequestsGet(page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of policies.
     * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the awsstspolicies instead of the names of the columns of a table. For example, in order to sort the policies descending by operator type identifier the value should be:  &#x60;&#x60;&#x60;sql orderBy id desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
     * @param {number} [page] Index of the requested page, where one corresponds to the first page.
     * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the awsstspolicies instead of the names of the columns of a table. For example, in order to retrieve all the policies of type  &#x60;operatorrole&#x60; should be:  &#x60;&#x60;&#x60;sql policy_type like \&#39;OperatorRole%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the policies  will be returned.
     * @param {number} [size] Maximum number of items that will be contained in the returned page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1AwsInquiriesStsPoliciesGet(order?: string, page?: number, search?: string, size?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1AwsInquiriesStsPoliciesGet(order, page, search, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of available vpcs of the cloud provider for specific region. IMPORTANT: This collection doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of available vpcs of the provider.
     * @param {number} [page] Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;.
     * @param {number} [size] Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of vpcs of the provider.
     * @param {CloudProviderData} [cloudProviderData] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1AwsInquiriesVpcsPost(page?: number, size?: number, cloudProviderData?: CloudProviderData, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1AwsInquiriesVpcsPost(page, size, cloudProviderData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of available regions of the cloud provider.  IMPORTANT: This collection doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of available regions of the provider.
     * @param {string} [cloudProviderId] 
     * @param {number} [page] Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;.
     * @param {number} [size] Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of regions of the provider.
     * @param {AWS} [aWS] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1CloudProvidersCloudProviderIdAvailableRegionsPost(cloudProviderId?: string, page?: number, size?: number, aWS?: AWS, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1CloudProvidersCloudProviderIdAvailableRegionsPost(cloudProviderId, page, size, aWS, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the cloud provider.
     * @param {string} [cloudProviderId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1CloudProvidersCloudProviderIdGet(cloudProviderId?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1CloudProvidersCloudProviderIdGet(cloudProviderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of regions of the cloud provider.  IMPORTANT: This collection doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of regions of the provider.
     * @param {string} [cloudProviderId] 
     * @param {number} [page] Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;.
     * @param {number} [size] Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of regions of the provider.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsGet(cloudProviderId?: string, page?: number, size?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsGet(cloudProviderId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the region.
     * @param {string} [cloudProviderId] 
     * @param {string} [regionId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsRegionIdGet(cloudProviderId?: string, regionId?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsRegionIdGet(cloudProviderId, regionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of cloud providers.
     * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the cloud provider instead of the names of the columns of a table. For example, in order to sort the clusters descending by name identifier the value should be:  &#x60;&#x60;&#x60;sql name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
     * @param {number} [page] Index of the requested page, where one corresponds to the first page.
     * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the cloud provider instead of the names of the columns of a table. For example, in order to retrieve all the cloud providers with a name starting with &#x60;A&#x60; the value should be:  &#x60;&#x60;&#x60;sql name like \&#39;A%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the clusters that the user has permission to see will be returned.
     * @param {number} [size] Maximum number of items that will be contained in the returned page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1CloudProvidersGet(order?: string, page?: number, search?: string, size?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1CloudProvidersGet(order, page, search, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [clusterId] 
     * @param {string} [addonInquiryId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdAddonInquiriesAddonInquiryIdGet(clusterId?: string, addonInquiryId?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdAddonInquiriesAddonInquiryIdGet(clusterId, addonInquiryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [clusterId] 
     * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the add-on instead of the names of the columns of a table. For example, in order to sort the add-ons descending by name the value should be:  &#x60;&#x60;&#x60;sql name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
     * @param {number} [page] Index of the requested page, where one corresponds to the first page.
     * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the add-on instead of the names of the columns of a table. For example, in order to retrieve all the add-ons with a name starting with &#x60;my&#x60; the value should be:  &#x60;&#x60;&#x60;sql name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the add-ons that the user has permission to see will be returned.
     * @param {number} [size] Maximum number of items that will be contained in the returned page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdAddonInquiriesGet(clusterId?: string, order?: string, page?: number, search?: string, size?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdAddonInquiriesGet(clusterId, order, page, search, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an add-on installation and remove it from the collection of add-on installations on the cluster.
     * @param {string} [clusterId] 
     * @param {string} [addoninstallationId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdDelete(clusterId?: string, addoninstallationId?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdDelete(clusterId, addoninstallationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the add-on installation.
     * @param {string} [clusterId] 
     * @param {string} [addoninstallationId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdGet(clusterId?: string, addoninstallationId?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdGet(clusterId, addoninstallationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the add-on installation.
     * @param {string} [clusterId] 
     * @param {string} [addoninstallationId] 
     * @param {AddOnInstallation} [addOnInstallation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdPatch(clusterId?: string, addoninstallationId?: string, addOnInstallation?: AddOnInstallation, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdPatch(clusterId, addoninstallationId, addOnInstallation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of add-on installations.
     * @param {string} [clusterId] 
     * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the add-on installation instead of the names of the columns of a table. For example, in order to sort the add-on installations descending by name the value should be:  &#x60;&#x60;&#x60;sql name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
     * @param {number} [page] Index of the requested page, where one corresponds to the first page.
     * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the add-on installation instead of the names of the columns of a table. For example, in order to retrieve all the add-on installations with a name starting with &#x60;my&#x60; the value should be:  &#x60;&#x60;&#x60;sql name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the add-on installations that the user has permission to see will be returned.
     * @param {number} [size] Maximum number of items that will be contained in the returned page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdAddonsGet(clusterId?: string, order?: string, page?: number, search?: string, size?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdAddonsGet(clusterId, order, page, search, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new add-on installation and add it to the collection of add-on installations on the cluster.
     * @param {string} [clusterId] 
     * @param {AddOnInstallation} [addOnInstallation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdAddonsPost(clusterId?: string, addOnInstallation?: AddOnInstallation, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdAddonsPost(clusterId, addOnInstallation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the AWS infrastructure access role grant.
     * @param {string} [clusterId] 
     * @param {string} [awsInfrastructureAccessRoleGrantId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsAwsInfrastructureAccessRoleGrantIdDelete(clusterId?: string, awsInfrastructureAccessRoleGrantId?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsAwsInfrastructureAccessRoleGrantIdDelete(clusterId, awsInfrastructureAccessRoleGrantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the AWS infrastructure access role grant.
     * @param {string} [clusterId] 
     * @param {string} [awsInfrastructureAccessRoleGrantId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsAwsInfrastructureAccessRoleGrantIdGet(clusterId?: string, awsInfrastructureAccessRoleGrantId?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsAwsInfrastructureAccessRoleGrantIdGet(clusterId, awsInfrastructureAccessRoleGrantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of AWS infrastructure access role grants.
     * @param {string} [clusterId] 
     * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the AWS infrastructure access role grant instead of the names of the columns of a table. For example, in order to sort the AWS infrastructure access role grants descending by user ARN the value should be:  &#x60;&#x60;&#x60;sql user_arn desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
     * @param {number} [page] Index of the requested page, where one corresponds to the first page.
     * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the AWS infrastructure access role grant instead of the names of the columns of a table. For example, in order to retrieve all the AWS infrastructure access role grants with a user ARN starting with &#x60;user&#x60; the value should be:  &#x60;&#x60;&#x60;sql user_arn like \&#39;%user\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the AWS infrastructure access role grants that the user has permission to see will be returned.
     * @param {number} [size] Maximum number of items that will be contained in the returned page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsGet(clusterId?: string, order?: string, page?: number, search?: string, size?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsGet(clusterId, order, page, search, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new AWS infrastructure access role grant and add it to the collection of AWS infrastructure access role grants on the cluster.
     * @param {string} [clusterId] 
     * @param {AWSInfrastructureAccessRoleGrant} [aWSInfrastructureAccessRoleGrant] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsPost(clusterId?: string, aWSInfrastructureAccessRoleGrant?: AWSInfrastructureAccessRoleGrant, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsPost(clusterId, aWSInfrastructureAccessRoleGrant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the clusterdeployment.
     * @param {string} [clusterId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdClusterdeploymentDelete(clusterId?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdClusterdeploymentDelete(clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the credentials of a cluster.
     * @param {string} [clusterId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdCredentialsGet(clusterId?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdCredentialsGet(clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the cluster.
     * @param {string} [clusterId] 
     * @param {boolean} [deprovision] If false it will only delete from OCM but not the actual cluster resources. false is only allowed for OCP clusters. true by default.
     * @param {boolean} [dryRun] Dry run flag is used to check if the operation can be completed, but won\&#39;t delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdDelete(clusterId?: string, deprovision?: boolean, dryRun?: boolean, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdDelete(clusterId, deprovision, dryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the external configuration.
     * @param {string} [clusterId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdExternalConfigurationGet(clusterId?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdExternalConfigurationGet(clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of labels.
     * @param {string} [clusterId] 
     * @param {number} [page] Index of the requested page, where one corresponds to the first page.
     * @param {number} [size] Number of items contained in the returned page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsGet(clusterId?: string, page?: number, size?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsGet(clusterId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the label.
     * @param {string} [clusterId] 
     * @param {string} [labelId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdDelete(clusterId?: string, labelId?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdDelete(clusterId, labelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the label.
     * @param {string} [clusterId] 
     * @param {string} [labelId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdGet(clusterId?: string, labelId?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdGet(clusterId, labelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the label.
     * @param {string} [clusterId] 
     * @param {string} [labelId] 
     * @param {Label} [label] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdPatch(clusterId?: string, labelId?: string, label?: Label, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdPatch(clusterId, labelId, label, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a new label to the cluster.
     * @param {string} [clusterId] 
     * @param {Label} [label] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsPost(clusterId?: string, label?: Label, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsPost(clusterId, label, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of syncsets.
     * @param {string} [clusterId] 
     * @param {number} [page] Index of the requested page, where one corresponds to the first page.
     * @param {number} [size] Number of items contained in the returned page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsGet(clusterId?: string, page?: number, size?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsGet(clusterId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a new syncset to the cluster.
     * @param {string} [clusterId] 
     * @param {Syncset} [syncset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsPost(clusterId?: string, syncset?: Syncset, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsPost(clusterId, syncset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the syncset.
     * @param {string} [clusterId] 
     * @param {string} [syncsetId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdDelete(clusterId?: string, syncsetId?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdDelete(clusterId, syncsetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the syncset.
     * @param {string} [clusterId] 
     * @param {string} [syncsetId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdGet(clusterId?: string, syncsetId?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdGet(clusterId, syncsetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the syncset.
     * @param {string} [clusterId] 
     * @param {string} [syncsetId] 
     * @param {Syncset} [syncset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdPatch(clusterId?: string, syncsetId?: string, syncset?: Syncset, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdPatch(clusterId, syncsetId, syncset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of reasons.
     * @param {string} [clusterId] 
     * @param {number} [page] Index of the requested page, where one corresponds to the first page.
     * @param {number} [size] Number of items contained in the returned page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdGateAgreementsGet(clusterId?: string, page?: number, size?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdGateAgreementsGet(clusterId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a new agreed version gate to the cluster.
     * @param {string} [clusterId] 
     * @param {VersionGateAgreement} [versionGateAgreement] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdGateAgreementsPost(clusterId?: string, versionGateAgreement?: VersionGateAgreement, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdGateAgreementsPost(clusterId, versionGateAgreement, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the version gate agreement.
     * @param {string} [clusterId] 
     * @param {string} [versionGateAgreementId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdGateAgreementsVersionGateAgreementIdDelete(clusterId?: string, versionGateAgreementId?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdGateAgreementsVersionGateAgreementIdDelete(clusterId, versionGateAgreementId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the version gate agreement.
     * @param {string} [clusterId] 
     * @param {string} [versionGateAgreementId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdGateAgreementsVersionGateAgreementIdGet(clusterId?: string, versionGateAgreementId?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdGateAgreementsVersionGateAgreementIdGet(clusterId, versionGateAgreementId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the cluster.
     * @param {string} [clusterId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdGet(clusterId?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdGet(clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of groups.
     * @param {string} [clusterId] 
     * @param {number} [page] Index of the requested page, where one corresponds to the first page.
     * @param {number} [size] Number of items contained in the returned page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdGroupsGet(clusterId?: string, page?: number, size?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdGroupsGet(clusterId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the group.
     * @param {string} [clusterId] 
     * @param {string} [groupId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdGroupsGroupIdGet(clusterId?: string, groupId?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdGroupsGroupIdGet(clusterId, groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of users.
     * @param {string} [clusterId] 
     * @param {string} [groupId] 
     * @param {number} [page] Index of the requested page, where one corresponds to the first page.
     * @param {number} [size] Number of items contained in the returned page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersGet(clusterId?: string, groupId?: string, page?: number, size?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersGet(clusterId, groupId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a new user to the group.
     * @param {string} [clusterId] 
     * @param {string} [groupId] 
     * @param {User} [user] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersPost(clusterId?: string, groupId?: string, user?: User, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersPost(clusterId, groupId, user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the user.
     * @param {string} [clusterId] 
     * @param {string} [groupId] 
     * @param {string} [userId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdDelete(clusterId?: string, groupId?: string, userId?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdDelete(clusterId, groupId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the user.
     * @param {string} [clusterId] 
     * @param {string} [groupId] 
     * @param {string} [userId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdGet(clusterId?: string, groupId?: string, userId?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdGet(clusterId, groupId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Initiates cluster hibernation. While hibernating a cluster will not consume any cloud provider infrastructure but will be counted for quota.
     * @param {string} [clusterId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdHibernatePost(clusterId?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdHibernatePost(clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of identity providers.
     * @param {string} [clusterId] 
     * @param {number} [page] Index of the requested page, where one corresponds to the first page.
     * @param {number} [size] Number of items contained in the returned page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdIdentityProvidersGet(clusterId?: string, page?: number, size?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdIdentityProvidersGet(clusterId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the identity provider.
     * @param {string} [clusterId] 
     * @param {string} [identityProviderId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdDelete(clusterId?: string, identityProviderId?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdDelete(clusterId, identityProviderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the identity provider.
     * @param {string} [clusterId] 
     * @param {string} [identityProviderId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdGet(clusterId?: string, identityProviderId?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdGet(clusterId, identityProviderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of _HTPasswd_ IDP users.
     * @param {string} [clusterId] 
     * @param {string} [identityProviderId] 
     * @param {number} [page] Index of the requested page, where one corresponds to the first page.
     * @param {number} [size] Number of items contained in the returned page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersGet(clusterId?: string, identityProviderId?: string, page?: number, size?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersGet(clusterId, identityProviderId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the user.
     * @param {string} [clusterId] 
     * @param {string} [identityProviderId] 
     * @param {string} [htpasswdUserId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdDelete(clusterId?: string, identityProviderId?: string, htpasswdUserId?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdDelete(clusterId, identityProviderId, htpasswdUserId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the user.
     * @param {string} [clusterId] 
     * @param {string} [identityProviderId] 
     * @param {string} [htpasswdUserId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdGet(clusterId?: string, identityProviderId?: string, htpasswdUserId?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdGet(clusterId, identityProviderId, htpasswdUserId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the user\'s password. The username is not editable
     * @param {string} [clusterId] 
     * @param {string} [identityProviderId] 
     * @param {string} [htpasswdUserId] 
     * @param {HTPasswdUser} [hTPasswdUser] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdPatch(clusterId?: string, identityProviderId?: string, htpasswdUserId?: string, hTPasswdUser?: HTPasswdUser, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdPatch(clusterId, identityProviderId, htpasswdUserId, hTPasswdUser, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds multiple new users to the _HTPasswd_ file.
     * @param {string} [clusterId] 
     * @param {string} [identityProviderId] 
     * @param {InlineObject} [inlineObject] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersImportPost(clusterId?: string, identityProviderId?: string, inlineObject?: InlineObject, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersImportPost(clusterId, identityProviderId, inlineObject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a new user to the _HTPasswd_ file.
     * @param {string} [clusterId] 
     * @param {string} [identityProviderId] 
     * @param {HTPasswdUser} [hTPasswdUser] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersPost(clusterId?: string, identityProviderId?: string, hTPasswdUser?: HTPasswdUser, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersPost(clusterId, identityProviderId, hTPasswdUser, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update identity provider in the cluster.
     * @param {string} [clusterId] 
     * @param {string} [identityProviderId] 
     * @param {IdentityProvider} [identityProvider] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdPatch(clusterId?: string, identityProviderId?: string, identityProvider?: IdentityProvider, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdPatch(clusterId, identityProviderId, identityProvider, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a new identity provider to the cluster.
     * @param {string} [clusterId] 
     * @param {IdentityProvider} [identityProvider] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdIdentityProvidersPost(clusterId?: string, identityProvider?: IdentityProvider, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdIdentityProvidersPost(clusterId, identityProvider, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of ingresses.
     * @param {string} [clusterId] 
     * @param {number} [page] Index of the requested page, where one corresponds to the first page.
     * @param {number} [size] Number of items contained in the returned page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdIngressesGet(clusterId?: string, page?: number, size?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdIngressesGet(clusterId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the ingress.
     * @param {string} [clusterId] 
     * @param {string} [ingressId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdIngressesIngressIdDelete(clusterId?: string, ingressId?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdIngressesIngressIdDelete(clusterId, ingressId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the ingress.
     * @param {string} [clusterId] 
     * @param {string} [ingressId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdIngressesIngressIdGet(clusterId?: string, ingressId?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdIngressesIngressIdGet(clusterId, ingressId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the ingress.
     * @param {string} [clusterId] 
     * @param {string} [ingressId] 
     * @param {Ingress} [ingress] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdIngressesIngressIdPatch(clusterId?: string, ingressId?: string, ingress?: Ingress, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdIngressesIngressIdPatch(clusterId, ingressId, ingress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates all ingresses
     * @param {string} [clusterId] 
     * @param {Array<Ingress>} [ingress] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdIngressesPatch(clusterId?: string, ingress?: Array<Ingress>, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdIngressesPatch(clusterId, ingress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a new ingress to the cluster.
     * @param {string} [clusterId] 
     * @param {Ingress} [ingress] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdIngressesPost(clusterId?: string, ingress?: Ingress, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdIngressesPost(clusterId, ingress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of reasons.
     * @param {string} [clusterId] 
     * @param {number} [page] Index of the requested page, where one corresponds to the first page.
     * @param {number} [size] Number of items contained in the returned page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsGet(clusterId?: string, page?: number, size?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsGet(clusterId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the reason.
     * @param {string} [clusterId] 
     * @param {string} [limitedSupportReasonId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsLimitedSupportReasonIdDelete(clusterId?: string, limitedSupportReasonId?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsLimitedSupportReasonIdDelete(clusterId, limitedSupportReasonId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the reason.
     * @param {string} [clusterId] 
     * @param {string} [limitedSupportReasonId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsLimitedSupportReasonIdGet(clusterId?: string, limitedSupportReasonId?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsLimitedSupportReasonIdGet(clusterId, limitedSupportReasonId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a new reason to the cluster.
     * @param {string} [clusterId] 
     * @param {LimitedSupportReason} [limitedSupportReason] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsPost(clusterId?: string, limitedSupportReason?: LimitedSupportReason, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsPost(clusterId, limitedSupportReason, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of log links.
     * @param {string} [clusterId] 
     * @param {number} [page] Index of the requested page, where one corresponds to the first page.
     * @param {number} [size] Number of items contained in the returned page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdLogsGet(clusterId?: string, page?: number, size?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdLogsGet(clusterId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the log.
     * @param {string} [clusterId] 
     * @param {number} [offset] Line offset to start logs from. if 0 retreive entire log. If offset &gt; #lines return an empty log.
     * @param {number} [tail] Returns the number of tail lines from the end of the log. If there are no line breaks or the number of lines &lt; tail return the entire log. Either \&#39;tail\&#39; or \&#39;offset\&#39; can be set. Not both. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdLogsInstallGet(clusterId?: string, offset?: number, tail?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdLogsInstallGet(clusterId, offset, tail, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the log.
     * @param {string} [clusterId] 
     * @param {number} [offset] Line offset to start logs from. if 0 retreive entire log. If offset &gt; #lines return an empty log.
     * @param {number} [tail] Returns the number of tail lines from the end of the log. If there are no line breaks or the number of lines &lt; tail return the entire log. Either \&#39;tail\&#39; or \&#39;offset\&#39; can be set. Not both. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdLogsUninstallGet(clusterId?: string, offset?: number, tail?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdLogsUninstallGet(clusterId, offset, tail, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of machine pools.
     * @param {string} [clusterId] 
     * @param {number} [page] Index of the requested page, where one corresponds to the first page.
     * @param {number} [size] Number of items contained in the returned page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdMachinePoolsGet(clusterId?: string, page?: number, size?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdMachinePoolsGet(clusterId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the machine pool.
     * @param {string} [clusterId] 
     * @param {string} [machinePoolId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdDelete(clusterId?: string, machinePoolId?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdDelete(clusterId, machinePoolId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the machine pool.
     * @param {string} [clusterId] 
     * @param {string} [machinePoolId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdGet(clusterId?: string, machinePoolId?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdGet(clusterId, machinePoolId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the machine pool.
     * @param {string} [clusterId] 
     * @param {string} [machinePoolId] 
     * @param {MachinePool} [machinePool] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdPatch(clusterId?: string, machinePoolId?: string, machinePool?: MachinePool, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdPatch(clusterId, machinePoolId, machinePool, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a new machine pool to the cluster.
     * @param {string} [clusterId] 
     * @param {MachinePool} [machinePool] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdMachinePoolsPost(clusterId?: string, machinePool?: MachinePool, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdMachinePoolsPost(clusterId, machinePool, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [clusterId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdMetricQueriesAlertsGet(clusterId?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdMetricQueriesAlertsGet(clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [clusterId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdMetricQueriesClusterOperatorsGet(clusterId?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdMetricQueriesClusterOperatorsGet(clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the metrics.
     * @param {string} [clusterId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdMetricQueriesCpuTotalByNodeRolesOsGet(clusterId?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdMetricQueriesCpuTotalByNodeRolesOsGet(clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [clusterId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdMetricQueriesNodesGet(clusterId?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdMetricQueriesNodesGet(clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the metrics.
     * @param {string} [clusterId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdMetricQueriesSocketTotalByNodeRolesOsGet(clusterId?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdMetricQueriesSocketTotalByNodeRolesOsGet(clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the cluster.
     * @param {string} [clusterId] 
     * @param {Cluster} [cluster] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdPatch(clusterId?: string, cluster?: Cluster, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdPatch(clusterId, cluster, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the product.
     * @param {string} [clusterId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdProductGet(clusterId?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdProductGet(clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the provision shard.
     * @param {string} [clusterId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdProvisionShardGet(clusterId?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdProvisionShardGet(clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of resources for a cluster in error state
     * @param {string} [clusterId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdResourcesGet(clusterId?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdResourcesGet(clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves currently available cluster resources
     * @param {string} [clusterId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdResourcesLiveGet(clusterId?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdResourcesLiveGet(clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resumes from Hibernation.
     * @param {string} [clusterId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdResumePost(clusterId?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdResumePost(clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [clusterId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdStatusGet(clusterId?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdStatusGet(clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of operator roles.
     * @param {string} [clusterId] 
     * @param {number} [page] Index of the requested page, where one corresponds to the first page.
     * @param {number} [size] Number of items that will be contained in the returned page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdStsOperatorRolesGet(clusterId?: string, page?: number, size?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdStsOperatorRolesGet(clusterId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the operator role.
     * @param {string} [clusterId] 
     * @param {string} [operatorIamRoleId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdStsOperatorRolesOperatorIamRoleIdDelete(clusterId?: string, operatorIamRoleId?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdStsOperatorRolesOperatorIamRoleIdDelete(clusterId, operatorIamRoleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a new operator role to the cluster.
     * @param {string} [clusterId] 
     * @param {OperatorIAMRole} [operatorIAMRole] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdStsOperatorRolesPost(clusterId?: string, operatorIAMRole?: OperatorIAMRole, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdStsOperatorRolesPost(clusterId, operatorIAMRole, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of upgrade policies.
     * @param {string} [clusterId] 
     * @param {number} [page] Index of the requested page, where one corresponds to the first page.
     * @param {number} [size] Number of items contained in the returned page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdUpgradePoliciesGet(clusterId?: string, page?: number, size?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdUpgradePoliciesGet(clusterId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a new upgrade policy to the cluster.
     * @param {string} [clusterId] 
     * @param {UpgradePolicy} [upgradePolicy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdUpgradePoliciesPost(clusterId?: string, upgradePolicy?: UpgradePolicy, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdUpgradePoliciesPost(clusterId, upgradePolicy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the upgrade policy.
     * @param {string} [clusterId] 
     * @param {string} [upgradePolicyId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdDelete(clusterId?: string, upgradePolicyId?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdDelete(clusterId, upgradePolicyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the upgrade policy.
     * @param {string} [clusterId] 
     * @param {string} [upgradePolicyId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdGet(clusterId?: string, upgradePolicyId?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdGet(clusterId, upgradePolicyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the upgrade policy.
     * @param {string} [clusterId] 
     * @param {string} [upgradePolicyId] 
     * @param {UpgradePolicy} [upgradePolicy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdPatch(clusterId?: string, upgradePolicyId?: string, upgradePolicy?: UpgradePolicy, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdPatch(clusterId, upgradePolicyId, upgradePolicy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the upgrade policy state.
     * @param {string} [clusterId] 
     * @param {string} [upgradePolicyId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdStateGet(clusterId?: string, upgradePolicyId?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdStateGet(clusterId, upgradePolicyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the upgrade policy state.
     * @param {string} [clusterId] 
     * @param {string} [upgradePolicyId] 
     * @param {UpgradePolicyState} [upgradePolicyState] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdStatePatch(clusterId?: string, upgradePolicyId?: string, upgradePolicyState?: UpgradePolicyState, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdStatePatch(clusterId, upgradePolicyId, upgradePolicyState, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of clusters.
     * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the cluster instead of the names of the columns of a table. For example, in order to sort the clusters descending by region identifier the value should be:  &#x60;&#x60;&#x60;sql region.id desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
     * @param {number} [page] Index of the requested page, where one corresponds to the first page.
     * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the cluster instead of the names of the columns of a table. For example, in order to retrieve all the clusters with a name starting with &#x60;my&#x60; in the &#x60;us-east-1&#x60; region the value should be:  &#x60;&#x60;&#x60;sql name like \&#39;my%\&#39; and region.id &#x3D; \&#39;us-east-1\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the clusters that the user has permission to see will be returned.
     * @param {number} [size] Maximum number of items that will be contained in the returned page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersGet(order?: string, page?: number, search?: string, size?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersGet(order, page, search, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Provision a new cluster and add it to the collection of clusters.  See the `register_cluster` method for adding an existing cluster.
     * @param {Cluster} [cluster] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersPost(cluster?: Cluster, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersPost(cluster, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the environment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1EnvironmentGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1EnvironmentGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the environment.  Attributes that can be updated are:  - `last_upgrade_available_check` - `last_limited_support_check`
     * @param {Environment} [environment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1EnvironmentPatch(environment?: Environment, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1EnvironmentPatch(environment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a new event to be tracked. When sending a new event request, it gets tracked in Prometheus, Pendo, CloudWatch, or whichever analytics client is configured as part of clusters service. This allows for reporting on events that happen outside of a regular API request, but are found to be useful for understanding customer needs and possible blockers.
     * @param {Event} [event] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1EventsPost(event?: Event, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1EventsPost(event, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the cluster flavour.
     * @param {string} [flavourId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1FlavoursFlavourIdGet(flavourId?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1FlavoursFlavourIdGet(flavourId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the flavour.  Attributes that can be updated are:  - `aws.infra_volume` - `aws.infra_instance_type` - `gcp.infra_instance_type`
     * @param {string} [flavourId] 
     * @param {Flavour} [flavour] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1FlavoursFlavourIdPatch(flavourId?: string, flavour?: Flavour, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1FlavoursFlavourIdPatch(flavourId, flavour, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the flavour instead of the names of the columns of a table. For example, in order to sort the flavours descending by name the value should be:  &#x60;&#x60;&#x60;sql name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
     * @param {number} [page] Index of the requested page, where one corresponds to the first page.
     * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the flavour instead of the names of the columns of a table. For example, in order to retrieve all the flavours with a name starting with &#x60;my&#x60;the value should be:  &#x60;&#x60;&#x60;sql name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the flavours that the user has permission to see will be returned.
     * @param {number} [size] Maximum number of items that will be contained in the returned page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1FlavoursGet(order?: string, page?: number, search?: string, size?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1FlavoursGet(order, page, search, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a new cluster flavour.
     * @param {Flavour} [flavour] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1FlavoursPost(flavour?: Flavour, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1FlavoursPost(flavour, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of encryption keys. IMPORTANT: This collection doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of available regions of the provider.
     * @param {number} [page] Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;.
     * @param {number} [size] Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of regions of the provider.
     * @param {CloudProviderData} [cloudProviderData] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1GcpInquiriesEncryptionKeysPost(page?: number, size?: number, cloudProviderData?: CloudProviderData, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1GcpInquiriesEncryptionKeysPost(page, size, cloudProviderData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of available key rings of the cloud provider. IMPORTANT: This collection doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of available regions of the provider.
     * @param {number} [page] Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;.
     * @param {number} [size] Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of key rings of the provider.
     * @param {CloudProviderData} [cloudProviderData] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1GcpInquiriesKeyRingsPost(page?: number, size?: number, cloudProviderData?: CloudProviderData, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1GcpInquiriesKeyRingsPost(page, size, cloudProviderData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of available regions of the cloud provider. IMPORTANT: This list doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of available regions of the provider.
     * @param {number} [page] Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;.
     * @param {number} [size] Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of regions of the provider.
     * @param {CloudProviderData} [cloudProviderData] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1GcpInquiriesRegionsPost(page?: number, size?: number, cloudProviderData?: CloudProviderData, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1GcpInquiriesRegionsPost(page, size, cloudProviderData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of available vpcs of the cloud provider for specific region. IMPORTANT: This collection doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of available vpcs of the provider.
     * @param {number} [page] Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;.
     * @param {number} [size] Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of vpcs of the provider.
     * @param {CloudProviderData} [cloudProviderData] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1GcpInquiriesVpcsPost(page?: number, size?: number, cloudProviderData?: CloudProviderData, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1GcpInquiriesVpcsPost(page, size, cloudProviderData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the version metadata.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1Get(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1Get(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of templates.
     * @param {number} [page] Index of the requested page, where one corresponds to the first page.
     * @param {number} [size] Number of items contained in the returned page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1LimitedSupportReasonTemplatesGet(page?: number, size?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1LimitedSupportReasonTemplatesGet(page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the template.
     * @param {string} [limitedSupportReasonTemplateId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1LimitedSupportReasonTemplatesLimitedSupportReasonTemplateIdGet(limitedSupportReasonTemplateId?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1LimitedSupportReasonTemplatesLimitedSupportReasonTemplateIdGet(limitedSupportReasonTemplateId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of machine types.
     * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the machine type instead of the names of the columns of a table. For example, in order to sort the machine types descending by name identifier the value should be:  &#x60;&#x60;&#x60;sql name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
     * @param {number} [page] Index of the requested page, where one corresponds to the first page.
     * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the machine type instead of the names of the columns of a table. For example, in order to retrieve all the machine types with a name starting with &#x60;A&#x60; the value should be:  &#x60;&#x60;&#x60;sql name like \&#39;A%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the machine types that the user has permission to see will be returned.
     * @param {number} [size] Maximum number of items that will be contained in the returned page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1MachineTypesGet(order?: string, page?: number, search?: string, size?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1MachineTypesGet(order, page, search, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of products.
     * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the product instead of the names of the columns of a table. For example, in order to sort the products descending by name the value should be:  &#x60;&#x60;&#x60;sql name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
     * @param {number} [page] Index of the requested page, where one corresponds to the first page.
     * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the product instead of the names of the columns of a table. For example, in order to retrieve all the products with a name starting with &#x60;my&#x60; the value should be:  &#x60;&#x60;&#x60;sql name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the products that the user has permission to see will be returned.
     * @param {number} [size] Maximum number of items that will be contained in the returned page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ProductsGet(order?: string, page?: number, search?: string, size?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ProductsGet(order, page, search, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the product.
     * @param {string} [productId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ProductsProductIdGet(productId?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ProductsProductIdGet(productId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] Index of the requested page, where one corresponds to the first page.
     * @param {number} [size] Maximum number of items that will be contained in the returned page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ProvisionShardsGet(page?: number, size?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ProvisionShardsGet(page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the provision shard.
     * @param {string} [provisionShardId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ProvisionShardsProvisionShardIdGet(provisionShardId?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ProvisionShardsProvisionShardIdGet(provisionShardId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of version gates.
     * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of an SQL statement, but using the names of the attributes of the version gate instead of the names of the columns of a table. For example, in order to sort the version gates descending by identifier the value should be:  &#x60;&#x60;&#x60;sql id desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
     * @param {number} [page] Index of the requested page, where one corresponds to the first page.
     * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the version gate instead of the names of the columns of a table.  If the parameter isn\&#39;t provided, or if the value is empty, then all the version gates that the user has permission to see will be returned.
     * @param {number} [size] Maximum number of items that will be contained in the returned page.  Default value is &#x60;100&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1VersionGatesGet(order?: string, page?: number, search?: string, size?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1VersionGatesGet(order, page, search, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a new version gate
     * @param {VersionGate} [versionGate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1VersionGatesPost(versionGate?: VersionGate, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1VersionGatesPost(versionGate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the version gate.
     * @param {string} [versionGateId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1VersionGatesVersionGateIdDelete(versionGateId?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1VersionGatesVersionGateIdDelete(versionGateId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the version gate.
     * @param {string} [versionGateId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1VersionGatesVersionGateIdGet(versionGateId?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1VersionGatesVersionGateIdGet(versionGateId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of versions.
     * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the version instead of the names of the columns of a table. For example, in order to sort the versions descending by identifier the value should be:  &#x60;&#x60;&#x60;sql id desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
     * @param {number} [page] Index of the requested page, where one corresponds to the first page.
     * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the version instead of the names of the columns of a table. For example, in order to retrieve all the versions that are enabled:  &#x60;&#x60;&#x60;sql enabled &#x3D; \&#39;t\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the versions that the user has permission to see will be returned.
     * @param {number} [size] Maximum number of items that will be contained in the returned page.  Default value is &#x60;100&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1VersionsGet(order?: string, page?: number, search?: string, size?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1VersionsGet(order, page, search, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the version.
     * @param {string} [versionId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1VersionsVersionIdGet(versionId?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1VersionsVersionIdGet(versionId, options).then((request) => request(this.axios, this.basePath));
    }
}
